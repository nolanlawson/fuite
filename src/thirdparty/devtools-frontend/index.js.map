{"version":3,"file":"index.js","sources":["../../../../front_end/models/heap_snapshot_model/HeapSnapshotModel.ts","../../../../front_end/entrypoints/heap_snapshot_worker/AllocationProfile.ts","../../../../front_end/core/i18n/DevToolsLocale.ts","../../../../front_end/third_party/i18n/localized-string-set.ts","../../../../front_end/third_party/i18n/i18n-impl.ts","../../../../front_end/core/platform/ArrayUtilities.ts","../../../../front_end/core/platform/MapUtilities.ts","../../../../front_end/core/platform/PromiseUtilities.ts","../../../../front_end/core/platform/StringUtilities.ts","../../../../front_end/core/platform/TypedArrayUtilities.ts","../../../../front_end/core/root/Runtime.ts","../../../../front_end/core/i18n/i18nImpl.ts","../../../../front_end/core/i18n/time-utilities.ts","../../../../front_end/entrypoints/heap_snapshot_worker/HeapSnapshot.ts","../../../../front_end/models/text_utils/TextUtils.ts","../../../../front_end/core/common/Base64.ts","../../../../front_end/core/common/Revealer.ts","../../../../front_end/core/common/SettingRegistration.ts","../../../../front_end/entrypoints/heap_snapshot_worker/HeapSnapshotLoader.ts"],"sourcesContent":["/*\n * Copyright (C) 2014 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nexport const HeapSnapshotProgressEvent = {\n  Update: 'ProgressUpdate',\n  BrokenSnapshot: 'BrokenSnapshot',\n};\n\nexport const baseSystemDistance = 100000000;\nexport const baseUnreachableDistance = baseSystemDistance * 2;\n\nexport class AllocationNodeCallers {\n  nodesWithSingleCaller: SerializedAllocationNode[];\n  branchingCallers: SerializedAllocationNode[];\n  constructor(nodesWithSingleCaller: SerializedAllocationNode[], branchingCallers: SerializedAllocationNode[]) {\n    this.nodesWithSingleCaller = nodesWithSingleCaller;\n    this.branchingCallers = branchingCallers;\n  }\n}\n\nexport class SerializedAllocationNode {\n  id: number;\n  name: string;\n  scriptName: string;\n  scriptId: number;\n  line: number;\n  column: number;\n  count: number;\n  size: number;\n  liveCount: number;\n  liveSize: number;\n  hasChildren: boolean;\n  constructor(\n      nodeId: number, functionName: string, scriptName: string, scriptId: number, line: number, column: number,\n      count: number, size: number, liveCount: number, liveSize: number, hasChildren: boolean) {\n    this.id = nodeId;\n    this.name = functionName;\n    this.scriptName = scriptName;\n    this.scriptId = scriptId;\n    this.line = line;\n    this.column = column;\n    this.count = count;\n    this.size = size;\n    this.liveCount = liveCount;\n    this.liveSize = liveSize;\n    this.hasChildren = hasChildren;\n  }\n}\n\nexport class AllocationStackFrame {\n  functionName: string;\n  scriptName: string;\n  scriptId: number;\n  line: number;\n  column: number;\n  constructor(functionName: string, scriptName: string, scriptId: number, line: number, column: number) {\n    this.functionName = functionName;\n    this.scriptName = scriptName;\n    this.scriptId = scriptId;\n    this.line = line;\n    this.column = column;\n  }\n}\n\nexport class Node {\n  id: number;\n  name: string;\n  distance: number;\n  nodeIndex: number;\n  retainedSize: number;\n  selfSize: number;\n  type: string;\n  canBeQueried: boolean;\n  detachedDOMTreeNode: boolean;\n  isAddedNotRemoved: boolean|null;\n  ignored: boolean;\n  constructor(\n      id: number, name: string, distance: number, nodeIndex: number, retainedSize: number, selfSize: number,\n      type: string) {\n    this.id = id;\n    this.name = name;\n    this.distance = distance;\n    this.nodeIndex = nodeIndex;\n    this.retainedSize = retainedSize;\n    this.selfSize = selfSize;\n    this.type = type;\n\n    this.canBeQueried = false;\n    this.detachedDOMTreeNode = false;\n    this.isAddedNotRemoved = null;\n    this.ignored = false;\n  }\n}\n\nexport class Edge {\n  name: string;\n  node: Node;\n  type: string;\n  edgeIndex: number;\n  isAddedNotRemoved: boolean|null;\n  constructor(name: string, node: Node, type: string, edgeIndex: number) {\n    this.name = name;\n    this.node = node;\n    this.type = type;\n    this.edgeIndex = edgeIndex;\n    this.isAddedNotRemoved = null;\n  }\n}\n\nexport class Aggregate {\n  count!: number;\n  distance!: number;\n  self!: number;\n  maxRet!: number;\n  type!: number;\n  name!: string;\n  idxs!: number[];\n  constructor() {\n  }\n}\n\nexport class AggregateForDiff {\n  indexes: number[];\n  ids: number[];\n  selfSizes: number[];\n  constructor() {\n    this.indexes = [];\n    this.ids = [];\n    this.selfSizes = [];\n  }\n}\n\nexport class Diff {\n  addedCount: number;\n  removedCount: number;\n  addedSize: number;\n  removedSize: number;\n  deletedIndexes: number[];\n  addedIndexes: number[];\n  countDelta!: number;\n  sizeDelta!: number;\n  constructor() {\n    this.addedCount = 0;\n    this.removedCount = 0;\n    this.addedSize = 0;\n    this.removedSize = 0;\n    this.deletedIndexes = [];\n    this.addedIndexes = [];\n  }\n}\n\nexport class DiffForClass {\n  addedCount!: number;\n  removedCount!: number;\n  addedSize!: number;\n  removedSize!: number;\n  deletedIndexes!: number[];\n  addedIndexes!: number[];\n  countDelta!: number;\n  sizeDelta!: number;\n  constructor() {\n  }\n}\n\nexport class ComparatorConfig {\n  fieldName1: string;\n  ascending1: boolean;\n  fieldName2: string;\n  ascending2: boolean;\n  constructor(fieldName1: string, ascending1: boolean, fieldName2: string, ascending2: boolean) {\n    this.fieldName1 = fieldName1;\n    this.ascending1 = ascending1;\n    this.fieldName2 = fieldName2;\n    this.ascending2 = ascending2;\n  }\n}\n\nexport class WorkerCommand {\n  callId!: number;\n  disposition!: string;\n  objectId!: number;\n  newObjectId!: number;\n  methodName!: string;\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodArguments!: any[];\n  source!: string;\n  constructor() {\n  }\n}\n\nexport class ItemsRange {\n  startPosition: number;\n  endPosition: number;\n  totalLength: number;\n  items: (Node|Edge)[];\n  constructor(startPosition: number, endPosition: number, totalLength: number, items: (Node|Edge)[]) {\n    this.startPosition = startPosition;\n    this.endPosition = endPosition;\n    this.totalLength = totalLength;\n    this.items = items;\n  }\n}\n\nexport class StaticData {\n  nodeCount: number;\n  rootNodeIndex: number;\n  totalSize: number;\n  maxJSObjectId: number;\n  constructor(nodeCount: number, rootNodeIndex: number, totalSize: number, maxJSObjectId: number) {\n    this.nodeCount = nodeCount;\n    this.rootNodeIndex = rootNodeIndex;\n    this.totalSize = totalSize;\n    this.maxJSObjectId = maxJSObjectId;\n  }\n}\n\nexport class Statistics {\n  total!: number;\n  v8heap!: number;\n  native!: number;\n  code!: number;\n  jsArrays!: number;\n  strings!: number;\n  system!: number;\n  constructor() {\n  }\n}\n\nexport class NodeFilter {\n  minNodeId: number|undefined;\n  maxNodeId: number|undefined;\n  allocationNodeId!: number|undefined;\n  filterName: string|undefined;\n  constructor(minNodeId?: number, maxNodeId?: number) {\n    this.minNodeId = minNodeId;\n    this.maxNodeId = maxNodeId;\n  }\n\n  equals(o: NodeFilter): boolean {\n    return this.minNodeId === o.minNodeId && this.maxNodeId === o.maxNodeId &&\n        this.allocationNodeId === o.allocationNodeId && this.filterName === o.filterName;\n  }\n}\n\nexport class SearchConfig {\n  query: string;\n  caseSensitive: boolean;\n  isRegex: boolean;\n  shouldJump: boolean;\n  jumpBackward: boolean;\n  constructor(query: string, caseSensitive: boolean, isRegex: boolean, shouldJump: boolean, jumpBackward: boolean) {\n    this.query = query;\n    this.caseSensitive = caseSensitive;\n    this.isRegex = isRegex;\n    this.shouldJump = shouldJump;\n    this.jumpBackward = jumpBackward;\n  }\n\n  toSearchRegex(_global?: boolean): {regex: RegExp, fromQuery: boolean} {\n    throw new Error('Unsupported operation on search config');\n  }\n}\n\nexport class Samples {\n  timestamps: number[];\n  lastAssignedIds: number[];\n  sizes: number[];\n  constructor(timestamps: number[], lastAssignedIds: number[], sizes: number[]) {\n    this.timestamps = timestamps;\n    this.lastAssignedIds = lastAssignedIds;\n    this.sizes = sizes;\n  }\n}\n\nexport class Location {\n  scriptId: number;\n  lineNumber: number;\n  columnNumber: number;\n  constructor(scriptId: number, lineNumber: number, columnNumber: number) {\n    this.scriptId = scriptId;\n    this.lineNumber = lineNumber;\n    this.columnNumber = columnNumber;\n  }\n}\n\nexport interface HeapSnapshotOptions {\n  heapSnapshotTreatBackingStoreAsContainingObject: boolean;\n}\n","/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\n\nimport {type LiveObjects, type Profile} from './HeapSnapshot.js';\n\nexport class AllocationProfile {\n  readonly #strings: string[];\n  #nextNodeId: number;\n  #functionInfos: FunctionAllocationInfo[];\n  #idToNode: {[x: number]: BottomUpAllocationNode|null};\n  readonly #idToTopDownNode: {[x: number]: TopDownAllocationNode};\n  #collapsedTopNodeIdToFunctionInfo: {[x: number]: FunctionAllocationInfo};\n  #traceTops: HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[]|null;\n\n  constructor(profile: Profile, liveObjectStats: LiveObjects) {\n    this.#strings = profile.strings;\n\n    this.#nextNodeId = 1;\n    this.#functionInfos = [];\n\n    this.#idToNode = {};\n\n    this.#idToTopDownNode = {};\n\n    this.#collapsedTopNodeIdToFunctionInfo = {};\n\n    this.#traceTops = null;\n\n    this.#buildFunctionAllocationInfos(profile);\n    this.#buildAllocationTree(profile, liveObjectStats);\n  }\n\n  #buildFunctionAllocationInfos(profile: Profile): void {\n    const strings = this.#strings;\n\n    const functionInfoFields = profile.snapshot.meta.trace_function_info_fields;\n    const functionNameOffset = functionInfoFields.indexOf('name');\n    const scriptNameOffset = functionInfoFields.indexOf('script_name');\n    const scriptIdOffset = functionInfoFields.indexOf('script_id');\n    const lineOffset = functionInfoFields.indexOf('line');\n    const columnOffset = functionInfoFields.indexOf('column');\n    const functionInfoFieldCount = functionInfoFields.length;\n\n    const rawInfos = profile.trace_function_infos;\n    const infoLength = rawInfos.length;\n    const functionInfos = this.#functionInfos = new Array(infoLength / functionInfoFieldCount);\n    let index = 0;\n    for (let i = 0; i < infoLength; i += functionInfoFieldCount) {\n      functionInfos[index++] = new FunctionAllocationInfo(\n          strings[rawInfos[i + functionNameOffset]], strings[rawInfos[i + scriptNameOffset]],\n          rawInfos[i + scriptIdOffset], rawInfos[i + lineOffset], rawInfos[i + columnOffset]);\n    }\n  }\n\n  #buildAllocationTree(profile: Profile, liveObjectStats: LiveObjects): TopDownAllocationNode {\n    const traceTreeRaw = profile.trace_tree;\n    const functionInfos = this.#functionInfos;\n    const idToTopDownNode = this.#idToTopDownNode;\n\n    const traceNodeFields = profile.snapshot.meta.trace_node_fields;\n    const nodeIdOffset = traceNodeFields.indexOf('id');\n    const functionInfoIndexOffset = traceNodeFields.indexOf('function_info_index');\n    const allocationCountOffset = traceNodeFields.indexOf('count');\n    const allocationSizeOffset = traceNodeFields.indexOf('size');\n    const childrenOffset = traceNodeFields.indexOf('children');\n    const nodeFieldCount = traceNodeFields.length;\n\n    function traverseNode(\n        // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        rawNodeArray: any, nodeOffset: any, parent: TopDownAllocationNode|null): TopDownAllocationNode {\n      const functionInfo = functionInfos[rawNodeArray[nodeOffset + functionInfoIndexOffset]];\n      const id = rawNodeArray[nodeOffset + nodeIdOffset];\n      const stats = liveObjectStats[id];\n      const liveCount = stats ? stats.count : 0;\n      const liveSize = stats ? stats.size : 0;\n      const result = new TopDownAllocationNode(\n          id, functionInfo, rawNodeArray[nodeOffset + allocationCountOffset],\n          rawNodeArray[nodeOffset + allocationSizeOffset], liveCount, liveSize, parent);\n      idToTopDownNode[id] = result;\n      functionInfo.addTraceTopNode(result);\n\n      const rawChildren = rawNodeArray[nodeOffset + childrenOffset];\n      for (let i = 0; i < rawChildren.length; i += nodeFieldCount) {\n        result.children.push(traverseNode(rawChildren, i, result));\n      }\n\n      return result;\n    }\n\n    return traverseNode(traceTreeRaw, 0, null);\n  }\n\n  serializeTraceTops(): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[] {\n    if (this.#traceTops) {\n      return this.#traceTops;\n    }\n\n    const result: HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[] = this.#traceTops = [];\n    const functionInfos = this.#functionInfos;\n    for (let i = 0; i < functionInfos.length; i++) {\n      const info = functionInfos[i];\n      if (info.totalCount === 0) {\n        continue;\n      }\n      const nodeId = this.#nextNodeId++;\n      const isRoot = i === 0;\n      result.push(this.#serializeNode(\n          nodeId, info, info.totalCount, info.totalSize, info.totalLiveCount, info.totalLiveSize, !isRoot));\n      this.#collapsedTopNodeIdToFunctionInfo[nodeId] = info;\n    }\n    result.sort(function(a, b) {\n      return b.size - a.size;\n    });\n    return result;\n  }\n\n  serializeCallers(nodeId: number): HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers {\n    let node = this.#ensureBottomUpNode(nodeId);\n    const nodesWithSingleCaller = [];\n    while (node.callers().length === 1) {\n      node = node.callers()[0];\n      nodesWithSingleCaller.push(this.#serializeCaller(node));\n    }\n\n    const branchingCallers = [];\n    const callers = node.callers();\n    for (let i = 0; i < callers.length; i++) {\n      branchingCallers.push(this.#serializeCaller(callers[i]));\n    }\n\n    return new HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers(nodesWithSingleCaller, branchingCallers);\n  }\n\n  serializeAllocationStack(traceNodeId: number): HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame[] {\n    let node: (TopDownAllocationNode|null)|TopDownAllocationNode = this.#idToTopDownNode[traceNodeId];\n    const result = [];\n    while (node) {\n      const functionInfo = node.functionInfo;\n      result.push(new HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame(\n          functionInfo.functionName, functionInfo.scriptName, functionInfo.scriptId, functionInfo.line,\n          functionInfo.column));\n      node = node.parent;\n    }\n    return result;\n  }\n\n  traceIds(allocationNodeId: number): number[] {\n    return this.#ensureBottomUpNode(allocationNodeId).traceTopIds;\n  }\n\n  #ensureBottomUpNode(nodeId: number): BottomUpAllocationNode {\n    let node = this.#idToNode[nodeId];\n    if (!node) {\n      const functionInfo = this.#collapsedTopNodeIdToFunctionInfo[nodeId];\n      node = functionInfo.bottomUpRoot();\n      delete this.#collapsedTopNodeIdToFunctionInfo[nodeId];\n      this.#idToNode[nodeId] = node;\n    }\n    return node as BottomUpAllocationNode;\n  }\n\n  #serializeCaller(node: BottomUpAllocationNode): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode {\n    const callerId = this.#nextNodeId++;\n    this.#idToNode[callerId] = node;\n    return this.#serializeNode(\n        callerId, node.functionInfo, node.allocationCount, node.allocationSize, node.liveCount, node.liveSize,\n        node.hasCallers());\n  }\n\n  #serializeNode(\n      nodeId: number, functionInfo: FunctionAllocationInfo, count: number, size: number, liveCount: number,\n      liveSize: number, hasChildren: boolean): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode {\n    return new HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode(\n        nodeId, functionInfo.functionName, functionInfo.scriptName, functionInfo.scriptId, functionInfo.line,\n        functionInfo.column, count, size, liveCount, liveSize, hasChildren);\n  }\n}\n\nexport class TopDownAllocationNode {\n  id: number;\n  functionInfo: FunctionAllocationInfo;\n  allocationCount: number;\n  allocationSize: number;\n  liveCount: number;\n  liveSize: number;\n  parent: TopDownAllocationNode|null;\n  children: TopDownAllocationNode[];\n  constructor(\n      id: number, functionInfo: FunctionAllocationInfo, count: number, size: number, liveCount: number,\n      liveSize: number, parent: TopDownAllocationNode|null) {\n    this.id = id;\n    this.functionInfo = functionInfo;\n    this.allocationCount = count;\n    this.allocationSize = size;\n    this.liveCount = liveCount;\n    this.liveSize = liveSize;\n    this.parent = parent;\n\n    this.children = [];\n  }\n}\n\nexport class BottomUpAllocationNode {\n  functionInfo: FunctionAllocationInfo;\n  allocationCount: number;\n  allocationSize: number;\n  liveCount: number;\n  liveSize: number;\n  traceTopIds: number[];\n  readonly #callersInternal: BottomUpAllocationNode[];\n  constructor(functionInfo: FunctionAllocationInfo) {\n    this.functionInfo = functionInfo;\n    this.allocationCount = 0;\n    this.allocationSize = 0;\n    this.liveCount = 0;\n    this.liveSize = 0;\n\n    this.traceTopIds = [];\n\n    this.#callersInternal = [];\n  }\n\n  addCaller(traceNode: TopDownAllocationNode): BottomUpAllocationNode {\n    const functionInfo = traceNode.functionInfo;\n    let result;\n    for (let i = 0; i < this.#callersInternal.length; i++) {\n      const caller = this.#callersInternal[i];\n      if (caller.functionInfo === functionInfo) {\n        result = caller;\n        break;\n      }\n    }\n    if (!result) {\n      result = new BottomUpAllocationNode(functionInfo);\n      this.#callersInternal.push(result);\n    }\n    return result;\n  }\n\n  callers(): BottomUpAllocationNode[] {\n    return this.#callersInternal;\n  }\n\n  hasCallers(): boolean {\n    return this.#callersInternal.length > 0;\n  }\n}\n\nexport class FunctionAllocationInfo {\n  functionName: string;\n  scriptName: string;\n  scriptId: number;\n  line: number;\n  column: number;\n  totalCount: number;\n  totalSize: number;\n  totalLiveCount: number;\n  totalLiveSize: number;\n  #traceTops: TopDownAllocationNode[];\n  #bottomUpTree?: BottomUpAllocationNode;\n  constructor(functionName: string, scriptName: string, scriptId: number, line: number, column: number) {\n    this.functionName = functionName;\n    this.scriptName = scriptName;\n    this.scriptId = scriptId;\n    this.line = line;\n    this.column = column;\n    this.totalCount = 0;\n    this.totalSize = 0;\n    this.totalLiveCount = 0;\n    this.totalLiveSize = 0;\n\n    this.#traceTops = [];\n  }\n\n  addTraceTopNode(node: TopDownAllocationNode): void {\n    if (node.allocationCount === 0) {\n      return;\n    }\n    this.#traceTops.push(node);\n    this.totalCount += node.allocationCount;\n    this.totalSize += node.allocationSize;\n    this.totalLiveCount += node.liveCount;\n    this.totalLiveSize += node.liveSize;\n  }\n\n  bottomUpRoot(): BottomUpAllocationNode|null {\n    if (!this.#traceTops.length) {\n      return null;\n    }\n    if (!this.#bottomUpTree) {\n      this.#buildAllocationTraceTree();\n    }\n    return this.#bottomUpTree as BottomUpAllocationNode;\n  }\n\n  #buildAllocationTraceTree(): void {\n    this.#bottomUpTree = new BottomUpAllocationNode(this);\n\n    for (let i = 0; i < this.#traceTops.length; i++) {\n      let node: (TopDownAllocationNode|null)|TopDownAllocationNode = this.#traceTops[i];\n      let bottomUpNode: BottomUpAllocationNode = this.#bottomUpTree;\n      const count = node.allocationCount;\n      const size = node.allocationSize;\n      const liveCount = node.liveCount;\n      const liveSize = node.liveSize;\n      const traceId = node.id;\n      while (true) {\n        bottomUpNode.allocationCount += count;\n        bottomUpNode.allocationSize += size;\n        bottomUpNode.liveCount += liveCount;\n        bottomUpNode.liveSize += liveSize;\n        bottomUpNode.traceTopIds.push(traceId);\n        node = node.parent;\n        if (node === null) {\n          break;\n        }\n\n        bottomUpNode = bottomUpNode.addCaller(node);\n      }\n    }\n  }\n}\n","// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nlet devToolsLocaleInstance: DevToolsLocale|null = null;\n\nexport interface DevToolsLocaleData {\n  settingLanguage: string;\n  navigatorLanguage: string;\n  lookupClosestDevToolsLocale: (locale: string) => string;\n}\n\nexport type DevToolsLocaleCreationOptions = {\n  create: true,\n  data: DevToolsLocaleData,\n}|{\n  create: false,\n};\n\n/**\n * Simple class that determines the DevTools locale based on:\n *   1) navigator.language, which matches the Chrome UI\n *   2) the value of the \"language\" Setting the user choses\n *   3) available locales in DevTools.\n *\n * The DevTools locale is only determined once during startup and\n * guaranteed to never change. Use this class when using\n * `Intl` APIs.\n */\nexport class DevToolsLocale {\n  readonly locale: string;\n  readonly lookupClosestDevToolsLocale: (locale: string) => string;\n\n  private constructor(data: DevToolsLocaleData) {\n    this.lookupClosestDevToolsLocale = data.lookupClosestDevToolsLocale;\n\n    // TODO(crbug.com/1163928): Use constant once setting actually exists.\n    if (data.settingLanguage === 'browserLanguage') {\n      this.locale = data.navigatorLanguage || 'en-US';\n    } else {\n      this.locale = data.settingLanguage;\n    }\n\n    this.locale = this.lookupClosestDevToolsLocale(this.locale);\n  }\n\n  static instance(opts: DevToolsLocaleCreationOptions = {create: false}): DevToolsLocale {\n    if (!devToolsLocaleInstance && !opts.create) {\n      throw new Error('No LanguageSelector instance exists yet.');\n    }\n\n    if (opts.create) {\n      devToolsLocaleInstance = new DevToolsLocale(opts.data);\n    }\n    return devToolsLocaleInstance as DevToolsLocale;\n  }\n\n  static removeInstance(): void {\n    devToolsLocaleInstance = null;\n  }\n\n  forceFallbackLocale(): void {\n    // Locale is 'readonly', this is the only case where we want to forceably\n    // overwrite the locale.\n    (this.locale as DevToolsLocale['locale']) = 'en-US';\n  }\n\n  /**\n   * Returns true iff DevTools supports the language of the passed locale.\n   * Note that it doesn't have to be a one-to-one match, e.g. if DevTools supports\n   * 'de', then passing 'de-AT' will return true.\n   */\n  languageIsSupportedByDevTools(localeString: string): boolean {\n    return localeLanguagesMatch(localeString, this.lookupClosestDevToolsLocale(localeString));\n  }\n}\n\n/**\n * Returns true iff the two locales have matching languages. This means the\n * passing 'de-AT' and 'de-DE' will return true, while 'de-DE' and 'en' will\n * return false.\n */\nexport function localeLanguagesMatch(localeString1: string, localeString2: string): boolean {\n  const locale1 = new Intl.Locale(localeString1);\n  const locale2 = new Intl.Locale(localeString2);\n  return locale1.language === locale2.language;\n}\n","// Copyright 2018 The Lighthouse Authors. All Rights Reserved.\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n\nimport {type LocalizedMessages, type UIStrings} from './i18n-impl.js';\n\nimport * as IntlMessageFormat from '../intl-messageformat/intl-messageformat.js';\n\nconst EMPTY_VALUES_OBJECT = {};\n\n/**\n * This class is usually created at module instantiation time and\n * holds the filename, the UIStrings object and a reference to\n * all the localization data.\n *\n * Later, once needed, users can request a `LocalizedStringSet` that represents\n * all the translated strings, in a given locale for the specific file and\n * UIStrings object.\n *\n * Please note that this class is implemented with invariant in mind that the\n * DevTools locale never changes. Otherwise we would have to use a Map as\n * the cache. For performance reasons, we store the single possible map entry\n * as a property directly.\n *\n * The DevTools locale CANNOT be passed via the constructor. When instances\n * of `RegisteredFileStrings` are created, the DevTools locale has not yet\n * been determined.\n */\nexport class RegisteredFileStrings {\n  private localizedStringSet?: LocalizedStringSet;\n\n  constructor(private filename: string, private stringStructure: UIStrings, private localizedMessages: Map<Intl.UnicodeBCP47LocaleIdentifier, LocalizedMessages>) {\n  }\n\n  getLocalizedStringSetFor(locale: Intl.UnicodeBCP47LocaleIdentifier): LocalizedStringSet {\n    if (this.localizedStringSet) {\n      return this.localizedStringSet;\n    }\n\n    const localeData = this.localizedMessages.get(locale);\n    if (!localeData) {\n      throw new Error(`No locale data registered for '${locale}'`);\n    }\n\n    this.localizedStringSet = new LocalizedStringSet(this.filename, this.stringStructure, locale, localeData);\n    return this.localizedStringSet;\n  }\n}\n\nexport type Values = Record<string, string|number|boolean>;\n\n/**\n * A set of translated strings for a single file in a specific locale.\n *\n * The class is a wrapper around `IntlMessageFormat#format` plus a cache\n * to speed up consecutive lookups of the same message.\n */\nexport class LocalizedStringSet {\n  private readonly cachedSimpleStrings = new Map<string, string>();\n  private readonly cachedMessageFormatters = new Map<string, IntlMessageFormat.IntlMessageFormat>();\n\n  /** For pseudo locales, use 'de-DE' for number formatting */\n  private readonly localeForFormatter: Intl.UnicodeBCP47LocaleIdentifier;\n\n  constructor(private filename: string, private stringStructure: UIStrings, locale: Intl.UnicodeBCP47LocaleIdentifier, private localizedMessages: LocalizedMessages) {\n    this.localeForFormatter = (locale === 'en-XA' || locale === 'en-XL') ? 'de-DE' : locale;\n  }\n\n  getLocalizedString(message: string, values: Values = EMPTY_VALUES_OBJECT): string {\n    if (values === EMPTY_VALUES_OBJECT || Object.keys(values).length === 0) {\n      return this.getSimpleLocalizedString(message);\n    }\n    return this.getFormattedLocalizedString(message, values);\n  }\n\n  getMessageFormatterFor(message: string): IntlMessageFormat.IntlMessageFormat {\n    const keyname = Object.keys(this.stringStructure).find(key => this.stringStructure[key] === message);\n    if (!keyname) {\n      throw new Error(`Unable to locate '${message}' in UIStrings object`);\n    }\n    const i18nId = `${this.filename} | ${keyname}`;\n    const localeMessage = this.localizedMessages[i18nId];\n\n    // The requested string might not yet have been collected into en-US.json or\n    // been translated yet. Fall back to the original TypeScript UIStrings message.\n    const messageToTranslate = localeMessage ? localeMessage.message : message;\n    return new IntlMessageFormat.IntlMessageFormat(messageToTranslate, this.localeForFormatter, undefined, {ignoreTag: true});\n  }\n\n  private getSimpleLocalizedString(message: string): string {\n    const cachedSimpleString = this.cachedSimpleStrings.get(message);\n    if (cachedSimpleString) {\n      return cachedSimpleString;\n    }\n\n    const formatter = this.getMessageFormatterFor(message);\n    const translatedString = formatter.format() as string;\n    this.cachedSimpleStrings.set(message, translatedString);\n    return translatedString;\n  }\n\n  private getFormattedLocalizedString(message: string, values: Values): string {\n    let formatter = this.cachedMessageFormatters.get(message);\n    if (!formatter) {\n      formatter = this.getMessageFormatterFor(message);\n      this.cachedMessageFormatters.set(message, formatter);\n    }\n\n    try {\n      return formatter.format(values) as string;\n    } catch (e) {\n      // The message could have been updated and use different placeholders then\n      // the translation. This is a rare edge case so it's fine to create a temporary\n      // IntlMessageFormat and fall back to the UIStrings message.\n      const formatter = new IntlMessageFormat.IntlMessageFormat(message, this.localeForFormatter, undefined, {ignoreTag: true});\n      return formatter.format(values) as string;\n    }\n  }\n}\n","// Copyright 2018 The Lighthouse Authors. All Rights Reserved.\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n\nimport {RegisteredFileStrings} from './localized-string-set.js';\n\nexport type UIStrings = Record<string, string>;\nexport type LocalizedMessages = Record<string, {message: string}>;\n\n/**\n * Encapsulates the global state of the i18n runtime.\n */\nexport class I18n {\n  readonly supportedLocales: ReadonlySet<Intl.UnicodeBCP47LocaleIdentifier>;\n\n  private localeData = new Map<Intl.UnicodeBCP47LocaleIdentifier, LocalizedMessages>();\n  readonly defaultLocale;\n\n  constructor(\n    supportedLocales: readonly Intl.UnicodeBCP47LocaleIdentifier[], defaultLocale: Intl.UnicodeBCP47LocaleIdentifier) {\n    this.defaultLocale = defaultLocale;\n\n    this.supportedLocales = new Set(supportedLocales);\n  }\n\n  registerLocaleData(locale: Intl.UnicodeBCP47LocaleIdentifier, messages: LocalizedMessages): void {\n    this.localeData.set(locale, messages);\n  }\n\n  registerFileStrings(filename: string, stringStructure: UIStrings): RegisteredFileStrings {\n    return new RegisteredFileStrings(filename, stringStructure, this.localeData);\n  }\n\n  /**\n   * Look up the best available locale for the requested language through these fall backs:\n   * - exact match\n   * - progressively shorter prefixes (`de-CH-1996` -> `de-CH` -> `de`)\n   * - the default locale if no match is found\n   */\n  lookupClosestSupportedLocale(locale: Intl.UnicodeBCP47LocaleIdentifier): Intl.UnicodeBCP47LocaleIdentifier {\n    const canonicalLocale: string = Intl.getCanonicalLocales(locale)[0];\n\n    const localeParts = canonicalLocale.split('-');\n    while (localeParts.length) {\n      const candidate = localeParts.join('-');\n      if (this.supportedLocales.has(candidate)) {\n        return candidate;\n      }\n      localeParts.pop();\n    }\n    return this.defaultLocale;\n  }\n}\n","// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const removeElement = <T>(array: T[], element: T, firstOnly?: boolean): boolean => {\n  let index = array.indexOf(element);\n  if (index === -1) {\n    return false;\n  }\n  if (firstOnly) {\n    array.splice(index, 1);\n    return true;\n  }\n  for (let i = index + 1, n = array.length; i < n; ++i) {\n    if (array[i] !== element) {\n      array[index++] = array[i];\n    }\n  }\n  array.length = index;\n  return true;\n};\n\ntype NumberComparator = (a: number, b: number) => number;\n\nfunction swap(array: number[], i1: number, i2: number): void {\n  const temp = array[i1];\n  array[i1] = array[i2];\n  array[i2] = temp;\n}\n\nfunction partition(\n    array: number[], comparator: NumberComparator, left: number, right: number, pivotIndex: number): number {\n  const pivotValue = array[pivotIndex];\n  swap(array, right, pivotIndex);\n  let storeIndex = left;\n  for (let i = left; i < right; ++i) {\n    if (comparator(array[i], pivotValue) < 0) {\n      swap(array, storeIndex, i);\n      ++storeIndex;\n    }\n  }\n  swap(array, right, storeIndex);\n  return storeIndex;\n}\n\nfunction quickSortRange(\n    array: number[], comparator: NumberComparator, left: number, right: number, sortWindowLeft: number,\n    sortWindowRight: number): void {\n  if (right <= left) {\n    return;\n  }\n  const pivotIndex = Math.floor(Math.random() * (right - left)) + left;\n  const pivotNewIndex = partition(array, comparator, left, right, pivotIndex);\n  if (sortWindowLeft < pivotNewIndex) {\n    quickSortRange(array, comparator, left, pivotNewIndex - 1, sortWindowLeft, sortWindowRight);\n  }\n  if (pivotNewIndex < sortWindowRight) {\n    quickSortRange(array, comparator, pivotNewIndex + 1, right, sortWindowLeft, sortWindowRight);\n  }\n}\n\nexport function sortRange(\n    array: number[], comparator: NumberComparator, leftBound: number, rightBound: number, sortWindowLeft: number,\n    sortWindowRight: number): number[] {\n  if (leftBound === 0 && rightBound === (array.length - 1) && sortWindowLeft === 0 && sortWindowRight >= rightBound) {\n    array.sort(comparator);\n  } else {\n    quickSortRange(array, comparator, leftBound, rightBound, sortWindowLeft, sortWindowRight);\n  }\n  return array;\n}\nexport const binaryIndexOf = <T, S>(array: T[], value: S, comparator: (a: S, b: T) => number): number => {\n  const index = lowerBound(array, value, comparator);\n  return index < array.length && comparator(value, array[index]) === 0 ? index : -1;\n};\n\nfunction mergeOrIntersect<T>(\n    array1: T[], array2: T[], comparator: (a: T, b: T) => number, mergeNotIntersect: boolean): T[] {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < array1.length && j < array2.length) {\n    const compareValue = comparator(array1[i], array2[j]);\n    if (mergeNotIntersect || !compareValue) {\n      result.push(compareValue <= 0 ? array1[i] : array2[j]);\n    }\n    if (compareValue <= 0) {\n      i++;\n    }\n    if (compareValue >= 0) {\n      j++;\n    }\n  }\n  if (mergeNotIntersect) {\n    while (i < array1.length) {\n      result.push(array1[i++]);\n    }\n    while (j < array2.length) {\n      result.push(array2[j++]);\n    }\n  }\n  return result;\n}\n\nexport const intersectOrdered = <T>(array1: T[], array2: T[], comparator: (a: T, b: T) => number): T[] => {\n  return mergeOrIntersect(array1, array2, comparator, false);\n};\n\nexport const mergeOrdered = <T>(array1: T[], array2: T[], comparator: (a: T, b: T) => number): T[] => {\n  return mergeOrIntersect(array1, array2, comparator, true);\n};\n\nexport const DEFAULT_COMPARATOR = (a: string|number, b: string|number): -1|0|1 => {\n  return a < b ? -1 : (a > b ? 1 : 0);\n};\n\n/**\n * Returns the index of the element closest to the needle that is equal to or\n * greater than it. Assumes that the provided array is sorted.\n *\n * If no element is found, the right bound is returned.\n *\n * Uses the provided comparator function to determine if two items are equal or\n * if one is greater than the other. If you are working with strings or\n * numbers, you can use ArrayUtilities.DEFAULT_COMPARATOR. Otherwise, you\n * should define one that takes the needle element and an element from the\n * array and returns a positive or negative number to indicate which is greater\n * than the other.\n *\n * When specified, |left| (inclusive) and |right| (exclusive) indices\n * define the search window.\n */\nexport function lowerBound<T>(\n    array: Uint32Array|Int32Array, needle: T, comparator: (needle: T, b: number) => number, left?: number,\n    right?: number): number;\nexport function lowerBound<S, T>(\n    array: S[], needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number;\nexport function lowerBound<S, T>(\n    array: readonly S[], needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number;\nexport function lowerBound<S, T, A extends S[]>(\n    array: A, needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number {\n  let l = left || 0;\n  let r = right !== undefined ? right : array.length;\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (comparator(needle, array[m]) > 0) {\n      l = m + 1;\n    } else {\n      r = m;\n    }\n  }\n  return r;\n}\n\n/**\n * Returns the index of the element closest to the needle that is greater than\n * it. Assumes that the provided array is sorted.\n *\n * If no element is found, the right bound is returned.\n *\n * Uses the provided comparator function to determine if two items are equal or\n * if one is greater than the other. If you are working with strings or\n * numbers, you can use ArrayUtilities.DEFAULT_COMPARATOR. Otherwise, you\n * should define one that takes the needle element and an element from the\n * array and returns a positive or negative number to indicate which is greater\n * than the other.\n *\n * When specified, |left| (inclusive) and |right| (exclusive) indices\n * define the search window.\n */\nexport function upperBound<T>(\n    array: Uint32Array, needle: T, comparator: (needle: T, b: number) => number, left?: number, right?: number): number;\nexport function upperBound<S, T>(\n    array: S[], needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number;\nexport function upperBound<S, T, A extends S[]>(\n    array: A, needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number {\n  let l = left || 0;\n  let r = right !== undefined ? right : array.length;\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (comparator(needle, array[m]) >= 0) {\n      l = m + 1;\n    } else {\n      r = m;\n    }\n  }\n  return r;\n}\n\nconst enum NearestSearchStart {\n  BEGINNING = 'BEGINNING',\n  END = 'END',\n}\n/**\n * Obtains the first or last item in the array that satisfies the predicate function.\n * So, for example, if the array were arr = [2, 4, 6, 8, 10], and you are looking for\n * the last item arr[i] such that arr[i] < 5  you would be returned 1, because\n * array[1] is 4, the last item in the array that satisfies the\n * predicate function.\n *\n * If instead you were looking for the first item in the same array that satisfies\n * arr[i] > 5 you would be returned 2 because array[2] = 6.\n *\n * Please note: this presupposes that the array is already ordered.\n */\nfunction nearestIndex<T>(\n    arr: readonly T[], predicate: (arrayItem: T) => boolean, searchStart: NearestSearchStart): number|null {\n  const searchFromEnd = searchStart === NearestSearchStart.END;\n  if (arr.length === 0) {\n    return null;\n  }\n\n  let left = 0;\n  let right = arr.length - 1;\n  let pivot = 0;\n  let matchesPredicate = false;\n  let moveToTheRight = false;\n  let middle = 0;\n  do {\n    middle = left + (right - left) / 2;\n    pivot = searchFromEnd ? Math.ceil(middle) : Math.floor(middle);\n    matchesPredicate = predicate(arr[pivot]);\n    moveToTheRight = matchesPredicate === searchFromEnd;\n    if (moveToTheRight) {\n      left = Math.min(right, pivot + (left === pivot ? 1 : 0));\n    } else {\n      right = Math.max(left, pivot + (right === pivot ? -1 : 0));\n    }\n  } while (right !== left);\n\n  // Special-case: the indexed item doesn't pass the predicate. This\n  // occurs when none of the items in the array are a match for the\n  // predicate.\n  if (!predicate(arr[left])) {\n    return null;\n  }\n  return left;\n}\n\n/**\n * Obtains the first item in the array that satisfies the predicate function.\n * So, for example, if the array was arr = [2, 4, 6, 8, 10], and you are looking for\n * the first item arr[i] such that arr[i] > 5 you would be returned 2, because\n * array[2] is 6, the first item in the array that satisfies the\n * predicate function.\n *\n * Please note: this presupposes that the array is already ordered.\n */\nexport function nearestIndexFromBeginning<T>(arr: T[], predicate: (arrayItem: T) => boolean): number|null {\n  return nearestIndex(arr, predicate, NearestSearchStart.BEGINNING);\n}\n\n/**\n * Obtains the last item in the array that satisfies the predicate function.\n * So, for example, if the array was arr = [2, 4, 6, 8, 10], and you are looking for\n * the last item arr[i] such that arr[i] < 5 you would be returned 1, because\n * arr[1] is 4, the last item in the array that satisfies the\n * predicate function.\n *\n * Please note: this presupposes that the array is already ordered.\n */\n\nexport function nearestIndexFromEnd<T>(arr: readonly T[], predicate: (arrayItem: T) => boolean): number|null {\n  return nearestIndex(arr, predicate, NearestSearchStart.END);\n}\n\n// Type guard for ensuring that `arr` does not contain null or undefined\nexport function arrayDoesNotContainNullOrUndefined<T>(arr: (T|null|undefined)[]): arr is T[] {\n  return !arr.includes(null) && !arr.includes(undefined);\n}\n","// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const inverse = function<K, V>(map: Map<K, V>): Multimap<V, K> {\n  const result = new Multimap<V, K>();\n  for (const [key, value] of map.entries()) {\n    result.set(value, key);\n  }\n  return result;\n};\n\nexport class Multimap<K, V> {\n  private map = new Map<K, Set<V>>();\n\n  set(key: K, value: V): void {\n    let set = this.map.get(key);\n    if (!set) {\n      set = new Set();\n      this.map.set(key, set);\n    }\n    set.add(value);\n  }\n\n  get(key: K): Set<V> {\n    return this.map.get(key) || new Set();\n  }\n\n  has(key: K): boolean {\n    return this.map.has(key);\n  }\n\n  hasValue(key: K, value: V): boolean {\n    const set = this.map.get(key);\n    if (!set) {\n      return false;\n    }\n    return set.has(value);\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n\n  delete(key: K, value: V): boolean {\n    const values = this.get(key);\n    if (!values) {\n      return false;\n    }\n    const result = values.delete(value);\n    if (!values.size) {\n      this.map.delete(key);\n    }\n    return result;\n  }\n\n  deleteAll(key: K): void {\n    this.map.delete(key);\n  }\n\n  keysArray(): K[] {\n    return [...this.map.keys()];\n  }\n\n  keys(): IterableIterator<K> {\n    return this.map.keys();\n  }\n\n  valuesArray(): V[] {\n    const result = [];\n    for (const set of this.map.values()) {\n      result.push(...set.values());\n    }\n    return result;\n  }\n\n  clear(): void {\n    this.map.clear();\n  }\n}\n\n/**\n * Gets value for key, assigning a default if value is falsy.\n */\nexport function getWithDefault<K extends {}, V>(\n    map: WeakMap<K, V>|Map<K, V>, key: K, defaultValueFactory: (key?: K) => V): V {\n  let value = map.get(key);\n  if (!value) {\n    value = defaultValueFactory(key);\n    map.set(key, value);\n  }\n\n  return value;\n}\n","// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Returns a new pending promise together with it's resolve and reject functions.\n *\n * Polyfill for https://github.com/tc39/proposal-promise-with-resolvers.\n */\nexport function promiseWithResolvers<T = unknown>(): {\n  promise: Promise<T>,\n  resolve: (value: T|PromiseLike<T>) => void,\n  reject: (error?: Error) => void,\n} {\n  let resolve!: (value: T|PromiseLike<T>) => void;\n  let reject!: (error?: Error) => void;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {promise, resolve, reject};\n}\n","// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const escapeCharacters = (inputString: string, charsToEscape: string): string => {\n  let foundChar = false;\n  for (let i = 0; i < charsToEscape.length; ++i) {\n    if (inputString.indexOf(charsToEscape.charAt(i)) !== -1) {\n      foundChar = true;\n      break;\n    }\n  }\n\n  if (!foundChar) {\n    return String(inputString);\n  }\n\n  let result = '';\n  for (let i = 0; i < inputString.length; ++i) {\n    if (charsToEscape.indexOf(inputString.charAt(i)) !== -1) {\n      result += '\\\\';\n    }\n    result += inputString.charAt(i);\n  }\n\n  return result;\n};\n\nconst toHexadecimal = (charCode: number, padToLength: number): string => {\n  return charCode.toString(16).toUpperCase().padStart(padToLength, '0');\n};\n\n// Remember to update the third group in the regexps patternsToEscape and\n// patternsToEscapePlusSingleQuote when adding new entries in this map.\nconst escapedReplacements = new Map([\n  ['\\b', '\\\\b'],\n  ['\\f', '\\\\f'],\n  ['\\n', '\\\\n'],\n  ['\\r', '\\\\r'],\n  ['\\t', '\\\\t'],\n  ['\\v', '\\\\v'],\n  ['\\'', '\\\\\\''],\n  ['\\\\', '\\\\\\\\'],\n  ['<!--', '\\\\x3C!--'],\n  ['<script', '\\\\x3Cscript'],\n  ['</script', '\\\\x3C/script'],\n]);\n\nexport const formatAsJSLiteral = (content: string): string => {\n  const patternsToEscape = /(\\\\|<(?:!--|\\/?script))|(\\p{Control})|(\\p{Surrogate})/gu;\n  const patternsToEscapePlusSingleQuote = /(\\\\|'|<(?:!--|\\/?script))|(\\p{Control})|(\\p{Surrogate})/gu;\n  const escapePattern = (match: string, pattern: string, controlChar: string, loneSurrogate: string): string => {\n    if (controlChar) {\n      if (escapedReplacements.has(controlChar)) {\n        // @ts-ignore https://github.com/microsoft/TypeScript/issues/13086\n        return escapedReplacements.get(controlChar);\n      }\n      const twoDigitHex = toHexadecimal(controlChar.charCodeAt(0), 2);\n      return '\\\\x' + twoDigitHex;\n    }\n    if (loneSurrogate) {\n      const fourDigitHex = toHexadecimal(loneSurrogate.charCodeAt(0), 4);\n      return '\\\\u' + fourDigitHex;\n    }\n    if (pattern) {\n      return escapedReplacements.get(pattern) || '';\n    }\n    return match;\n  };\n\n  let escapedContent = '';\n  let quote = '';\n  if (!content.includes('\\'')) {\n    quote = '\\'';\n    escapedContent = content.replaceAll(patternsToEscape, escapePattern);\n  } else if (!content.includes('\"')) {\n    quote = '\"';\n    escapedContent = content.replaceAll(patternsToEscape, escapePattern);\n  } else if (!content.includes('`') && !content.includes('${')) {\n    quote = '`';\n    escapedContent = content.replaceAll(patternsToEscape, escapePattern);\n  } else {\n    quote = '\\'';\n    escapedContent = content.replaceAll(patternsToEscapePlusSingleQuote, escapePattern);\n  }\n  return `${quote}${escapedContent}${quote}`;\n};\n\n/**\n * This implements a subset of the sprintf() function described in the Single UNIX\n * Specification. It supports the %s, %f, %d, and %% formatting specifiers, and\n * understands the %m$d notation to select the m-th parameter for this substitution,\n * as well as the optional precision for %s, %f, and %d.\n *\n * @param fmt format string.\n * @param args parameters to the format string.\n * @returns the formatted output string.\n */\nexport const sprintf = (fmt: string, ...args: unknown[]): string => {\n  let argIndex = 0;\n  const RE = /%(?:(\\d+)\\$)?(?:\\.(\\d*))?([%dfs])/g;\n  return fmt.replaceAll(RE, (_: string, index?: string, precision?: string, specifier?: string) => {\n    if (specifier === '%') {\n      return '%';\n    }\n    if (index !== undefined) {\n      argIndex = parseInt(index, 10) - 1;\n      if (argIndex < 0) {\n        throw new RangeError(`Invalid parameter index ${argIndex + 1}`);\n      }\n    }\n    if (argIndex >= args.length) {\n      throw new RangeError(`Expected at least ${argIndex + 1} format parameters, but only ${args.length} where given.`);\n    }\n    if (specifier === 's') {\n      const argValue = String(args[argIndex++]);\n      if (precision !== undefined) {\n        return argValue.substring(0, Number(precision));\n      }\n      return argValue;\n    }\n    let argValue = Number(args[argIndex++]);\n    if (isNaN(argValue)) {\n      argValue = 0;\n    }\n    if (specifier === 'd') {\n      return String(Math.floor(argValue)).padStart(Number(precision), '0');\n    }\n    if (precision !== undefined) {\n      return argValue.toFixed(Number(precision));\n    }\n    return String(argValue);\n  });\n};\n\nexport const toBase64 = (inputString: string): string => {\n  /* note to the reader: we can't use btoa here because we need to\n   * support Unicode correctly. See the test cases for this function and\n   * also\n   * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem\n   */\n\n  function encodeBits(b: number): number {\n    return b < 26 ? b + 65 : b < 52 ? b + 71 : b < 62 ? b - 4 : b === 62 ? 43 : b === 63 ? 47 : 65;\n  }\n  const encoder = new TextEncoder();\n  const data = encoder.encode(inputString.toString());\n  const n = data.length;\n  let encoded = '';\n  if (n === 0) {\n    return encoded;\n  }\n  let shift;\n  let v = 0;\n  for (let i = 0; i < n; i++) {\n    shift = i % 3;\n    v |= data[i] << (16 >>> shift & 24);\n    if (shift === 2) {\n      encoded += String.fromCharCode(\n          encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), encodeBits(v >>> 6 & 63), encodeBits(v & 63));\n      v = 0;\n    }\n  }\n  if (shift === 0) {\n    encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), 61, 61);\n  } else if (shift === 1) {\n    encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), encodeBits(v >>> 6 & 63), 61);\n  }\n  return encoded;\n};\n\nexport const findIndexesOfSubString = (inputString: string, searchString: string): number[] => {\n  const matches = [];\n  let i = inputString.indexOf(searchString);\n  while (i !== -1) {\n    matches.push(i);\n    i = inputString.indexOf(searchString, i + searchString.length);\n  }\n  return matches;\n};\n\nexport const findLineEndingIndexes = (inputString: string): number[] => {\n  const endings = findIndexesOfSubString(inputString, '\\n');\n  endings.push(inputString.length);\n  return endings;\n};\n\nexport const isWhitespace = (inputString: string): boolean => {\n  return /^\\s*$/.test(inputString);\n};\n\nexport const trimURL = (url: string, baseURLDomain?: string): string => {\n  let result = url.replace(/^(https|http|file):\\/\\//i, '');\n  if (baseURLDomain) {\n    if (result.toLowerCase().startsWith(baseURLDomain.toLowerCase())) {\n      result = result.substr(baseURLDomain.length);\n    }\n  }\n  return result;\n};\n\nexport const collapseWhitespace = (inputString: string): string => {\n  return inputString.replace(/[\\s\\xA0]+/g, ' ');\n};\n\nexport const reverse = (inputString: string): string => {\n  return inputString.split('').reverse().join('');\n};\n\nexport const replaceControlCharacters = (inputString: string): string => {\n  // Replace C0 and C1 control character sets with replacement character.\n  // Do not replace '\\t', \\n' and '\\r'.\n  return inputString.replace(/[\\0-\\x08\\x0B\\f\\x0E-\\x1F\\x80-\\x9F]/g, '\\uFFFD');\n};\n\nexport const countWtf8Bytes = (inputString: string): number => {\n  let count = 0;\n  for (let i = 0; i < inputString.length; i++) {\n    const c = inputString.charCodeAt(i);\n    if (c <= 0x7F) {\n      count++;\n    } else if (c <= 0x07FF) {\n      count += 2;\n    } else if (c < 0xD800 || 0xDFFF < c) {\n      count += 3;\n    } else {\n      if (c <= 0xDBFF && i + 1 < inputString.length) {\n        // The current character is a leading surrogate, and there is a\n        // next character.\n        const next = inputString.charCodeAt(i + 1);\n        if (0xDC00 <= next && next <= 0xDFFF) {\n          // The next character is a trailing surrogate, meaning this\n          // is a surrogate pair.\n          count += 4;\n          i++;\n          continue;\n        }\n      }\n      count += 3;\n    }\n  }\n  return count;\n};\n\nexport const stripLineBreaks = (inputStr: string): string => {\n  return inputStr.replace(/(\\r)?\\n/g, '');\n};\n\nconst EXTENDED_KEBAB_CASE_REGEXP = /^([a-z0-9]+(?:-[a-z0-9]+)*\\.)*[a-z0-9]+(?:-[a-z0-9]+)*$/;\n\n/**\n * Tests if the `inputStr` is following the extended Kebab Case naming convetion,\n * where words are separated with either a dash (`-`) or a dot (`.`), and all\n * characters must be lower-case alphanumeric.\n *\n * For example, it will yield `true` for `'my.amazing-string.literal'`, but `false`\n * for `'Another.AmazingLiteral'` or '`another_amazing_literal'`.\n *\n * @param inputStr the input string to test.\n * @return `true` if the `inputStr` follows the extended Kebab Case convention.\n */\nexport const isExtendedKebabCase = (inputStr: string): boolean => {\n  return EXTENDED_KEBAB_CASE_REGEXP.test(inputStr);\n};\n\nexport const toTitleCase = (inputStr: string): string => {\n  return inputStr.substring(0, 1).toUpperCase() + inputStr.substring(1);\n};\n\nexport const removeURLFragment = (inputStr: string): string => {\n  const url = new URL(inputStr);\n  url.hash = '';\n  return url.toString();\n};\n\nconst SPECIAL_REGEX_CHARACTERS = '^[]{}()\\\\.^$*+?|-,';\n\nexport const regexSpecialCharacters = function(): string {\n  return SPECIAL_REGEX_CHARACTERS;\n};\n\nexport const filterRegex = function(query: string): RegExp {\n  let regexString = '^(?:.*\\\\0)?';  // Start from beginning or after a \\0\n  for (let i = 0; i < query.length; ++i) {\n    let c = query.charAt(i);\n    if (SPECIAL_REGEX_CHARACTERS.indexOf(c) !== -1) {\n      c = '\\\\' + c;\n    }\n    regexString += '[^\\\\0' + c + ']*' + c;\n  }\n  return new RegExp(regexString, 'i');\n};\n\nexport const createSearchRegex = function(\n    query: string, caseSensitive: boolean, isRegex: boolean, matchWholeWord: boolean = false): RegExp {\n  const regexFlags = caseSensitive ? 'g' : 'gi';\n  let regexObject;\n\n  if (isRegex) {\n    try {\n      regexObject = new RegExp(query, regexFlags);\n    } catch (e) {\n      // Silent catch.\n    }\n  }\n\n  if (!regexObject) {\n    regexObject = createPlainTextSearchRegex(query, regexFlags);\n  }\n\n  if (matchWholeWord && regexObject) {\n    regexObject = new RegExp(`\\\\b${regexObject.source}\\\\b`, regexFlags);\n  }\n\n  return regexObject;\n};\n\nexport const caseInsensetiveComparator = function(a: string, b: string): number {\n  a = a.toUpperCase();\n  b = b.toUpperCase();\n  if (a === b) {\n    return 0;\n  }\n  return a > b ? 1 : -1;\n};\n\nexport const hashCode = function(string?: string): number {\n  if (!string) {\n    return 0;\n  }\n  // Hash algorithm for substrings is described in \"ber die Komplexitt der Multiplikation in\n  // eingeschrnkten Branchingprogrammmodellen\" by Woelfe.\n  // http://opendatastructures.org/versions/edition-0.1d/ods-java/node33.html#SECTION00832000000000000000\n  const p = ((1 << 30) * 4 - 5);  // prime: 2^32 - 5\n  const z = 0x5033d967;           // 32 bits from random.org\n  const z2 = 0x59d2f15d;          // random odd 32 bit number\n  let s = 0;\n  let zi = 1;\n  for (let i = 0; i < string.length; i++) {\n    const xi = string.charCodeAt(i) * z2;\n    s = (s + zi * xi) % p;\n    zi = (zi * z) % p;\n  }\n  s = (s + zi * (p - 1)) % p;\n  return Math.abs(s | 0);\n};\n\nexport const compare = (a: string, b: string): number => {\n  if (a > b) {\n    return 1;\n  }\n  if (a < b) {\n    return -1;\n  }\n  return 0;\n};\n\nexport const trimMiddle = (str: string, maxLength: number): string => {\n  if (str.length <= maxLength) {\n    return String(str);\n  }\n  let leftHalf = maxLength >> 1;\n  let rightHalf = maxLength - leftHalf - 1;\n  if ((str.codePointAt(str.length - rightHalf - 1) as number) >= 0x10000) {\n    --rightHalf;\n    ++leftHalf;\n  }\n  if (leftHalf > 0 && (str.codePointAt(leftHalf - 1) as number) >= 0x10000) {\n    --leftHalf;\n  }\n  return str.substr(0, leftHalf) + '' + str.substr(str.length - rightHalf, rightHalf);\n};\n\nexport const trimEndWithMaxLength = (str: string, maxLength: number): string => {\n  if (str.length <= maxLength) {\n    return String(str);\n  }\n  return str.substr(0, maxLength - 1) + '';\n};\n\nexport const escapeForRegExp = (str: string): string => {\n  return escapeCharacters(str, SPECIAL_REGEX_CHARACTERS);\n};\n\nexport const naturalOrderComparator = (a: string, b: string): number => {\n  const chunk = /^\\d+|^\\D+/;\n  let chunka, chunkb, anum, bnum;\n  while (true) {\n    if (a) {\n      if (!b) {\n        return 1;\n      }\n    } else {\n      if (b) {\n        return -1;\n      }\n      return 0;\n    }\n    chunka = (a.match(chunk) as string[])[0];\n    chunkb = (b.match(chunk) as string[])[0];\n    anum = !Number.isNaN(Number(chunka));\n    bnum = !Number.isNaN(Number(chunkb));\n    if (anum && !bnum) {\n      return -1;\n    }\n    if (bnum && !anum) {\n      return 1;\n    }\n    if (anum && bnum) {\n      const diff = Number(chunka) - Number(chunkb);\n      if (diff) {\n        return diff;\n      }\n      if (chunka.length !== chunkb.length) {\n        if (!Number(chunka) && !Number(chunkb)) {  // chunks are strings of all 0s (special case)\n          return chunka.length - chunkb.length;\n        }\n        return chunkb.length - chunka.length;\n      }\n    } else if (chunka !== chunkb) {\n      return (chunka < chunkb) ? -1 : 1;\n    }\n    a = a.substring(chunka.length);\n    b = b.substring(chunkb.length);\n  }\n};\n\nexport const base64ToSize = function(content: string|null): number {\n  if (!content) {\n    return 0;\n  }\n  let size = content.length * 3 / 4;\n  if (content[content.length - 1] === '=') {\n    size--;\n  }\n  if (content.length > 1 && content[content.length - 2] === '=') {\n    size--;\n  }\n  return size;\n};\n\nexport const SINGLE_QUOTE = '\\'';\nexport const DOUBLE_QUOTE = '\"';\nconst BACKSLASH = '\\\\';\n\nexport const findUnclosedCssQuote = function(str: string): string {\n  let unmatchedQuote = '';\n  for (let i = 0; i < str.length; ++i) {\n    const char = str[i];\n    if (char === BACKSLASH) {\n      i++;\n      continue;\n    }\n    if (char === SINGLE_QUOTE || char === DOUBLE_QUOTE) {\n      if (unmatchedQuote === char) {\n        unmatchedQuote = '';\n      } else if (unmatchedQuote === '') {\n        unmatchedQuote = char;\n      }\n    }\n  }\n  return unmatchedQuote;\n};\n\nexport const countUnmatchedLeftParentheses = (str: string): number => {\n  let unmatchedCount = 0;\n  for (const c of str) {\n    if (c === '(') {\n      unmatchedCount++;\n    } else if (c === ')' && unmatchedCount > 0) {\n      unmatchedCount--;\n    }\n  }\n  return unmatchedCount;\n};\n\nexport const createPlainTextSearchRegex = function(query: string, flags?: string): RegExp {\n  // This should be kept the same as the one in StringUtil.cpp.\n  let regex = '';\n  for (let i = 0; i < query.length; ++i) {\n    const c = query.charAt(i);\n    if (regexSpecialCharacters().indexOf(c) !== -1) {\n      regex += '\\\\';\n    }\n    regex += c;\n  }\n  return new RegExp(regex, flags || '');\n};\n\nclass LowerCaseStringTag {\n  private lowerCaseStringTag: (string|undefined);\n}\n\nexport type LowerCaseString = string&LowerCaseStringTag;\n\nexport const toLowerCaseString = function(input: string): LowerCaseString {\n  return input.toLowerCase() as LowerCaseString;\n};\n\nconst WORD = /[A-Z]{2,}(?=[A-Z0-9][a-z0-9]+|\\b|_)|[A-Za-z][0-9]+[a-z]?|[A-Z]?[a-z]+|[0-9][A-Za-z]+|[A-Z]|[0-9]+|[.]/g;\n//            <---1---><------------2-----------> <---------3--------> <-----4----> <------5-----> <-----6----> <7>\n// 1: two or more consecutive uppercase letters. This is useful for identifying acronyms\n// 2: lookahead assertion that matches a word boundary\n// 3: numeronym: single letter followed by number and another letter\n// 4: word starting with an optional uppercase letter\n// 5: single digit followed by word to handle '3D' or '2px' (this might be controverial)\n// 6: single uppercase letter or number\n// 7: a dot character. We extract it into a separate word and remove dashes around it later.\n//    This is makes more sense conceptually and allows accounting for all possible word variants.\n//    Making dot a part of a word prevent us from handling acronyms or numeronyms after the word\n//    correctly without making the RegExp prohibitively complicated.\n// https://regex101.com/r/FhMVKc/1\nexport const toKebabCase = function(input: string): Lowercase<string> {\n  return (input.match?.(WORD)?.map(w => w.toLowerCase()).join('-').replaceAll('-.-', '.') || input) as\n      Lowercase<string>;\n};\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function toKebabCaseKeys(settingValue: {\n  [x: string]: any,\n}): {[x: string]: any} {\n  const result: {\n    [x: string]: any,\n  } = {};\n  for (const [key, value] of Object.entries(settingValue)) {\n    result[toKebabCase(key)] = value;\n  }\n  return result;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n// Replaces the last ocurrence of parameter `search` with parameter `replacement` in `input`\nexport const replaceLast = function(input: string, search: string, replacement: string): string {\n  const replacementStartIndex = input.lastIndexOf(search);\n  if (replacementStartIndex === -1) {\n    return input;\n  }\n\n  return input.slice(0, replacementStartIndex) + input.slice(replacementStartIndex).replace(search, replacement);\n};\n\nexport const stringifyWithPrecision = function stringifyWithPrecision(s: number, precision = 2): string {\n  if (precision === 0) {\n    return s.toFixed(0);\n  }\n  const string = s.toFixed(precision).replace(/\\.?0*$/, '');\n  return string === '-0' ? '0' : string;\n};\n\n/**\n * Somewhat efficiently concatenates 2 base64 encoded strings.\n */\nexport const concatBase64 = function(lhs: string, rhs: string): string {\n  if (lhs.length === 0 || !lhs.endsWith('=')) {\n    // Empty string or no padding, we can straight-up concatenate.\n    return lhs + rhs;\n  }\n  const lhsLeaveAsIs = lhs.substring(0, lhs.length - 4);\n  const lhsToDecode = lhs.substring(lhs.length - 4);\n  return lhsLeaveAsIs + window.btoa(window.atob(lhsToDecode) + window.atob(rhs));\n};\n","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * An object which provides functionality similar to Uint32Array. It may be\n * implemented as:\n * 1. A Uint32Array,\n * 2. An array of Uint32Arrays, to support more data than Uint32Array, or\n * 3. A plain array, in which case the length may change by setting values.\n */\nexport interface BigUint32Array {\n  get length(): number;\n  getValue(index: number): number;\n  setValue(index: number, value: number): void;\n  asUint32ArrayOrFail(): Uint32Array;\n  asArrayOrFail(): number[];\n}\n\n/**\n * @returns A BigUint32Array implementation which is based on Array.\n * This means that its length automatically expands to include the highest index\n * used, and asArrayOrFail will succeed.\n */\nexport function createExpandableBigUint32Array(): BigUint32Array {\n  return new ExpandableBigUint32ArrayImpl();\n}\n\n/**\n * @returns A BigUint32Array implementation which is based on Uint32Array.\n * If the length is small enough to fit in a single Uint32Array, then\n * asUint32ArrayOrFail will succeed. Otherwise, it will throw an exception.\n */\nexport function createFixedBigUint32Array(length: number, maxLengthForTesting?: number): BigUint32Array {\n  try {\n    if (maxLengthForTesting !== undefined && length > maxLengthForTesting) {\n      // Simulate allocation failure.\n      throw new RangeError();\n    }\n    return new BasicBigUint32ArrayImpl(length);\n  } catch {\n    // We couldn't allocate a big enough ArrayBuffer.\n    return new SplitBigUint32ArrayImpl(length, maxLengthForTesting);\n  }\n}\n\nclass BasicBigUint32ArrayImpl extends Uint32Array implements BigUint32Array {\n  getValue(index: number): number {\n    return this[index];\n  }\n  setValue(index: number, value: number): void {\n    this[index] = value;\n  }\n  asUint32ArrayOrFail(): Uint32Array {\n    return this;\n  }\n  asArrayOrFail(): number[] {\n    throw new Error('Not an array');\n  }\n}\n\nclass SplitBigUint32ArrayImpl implements BigUint32Array {\n  #data: Uint32Array[];\n  #partLength: number;\n  length: number;\n\n  constructor(length: number, maxLengthForTesting?: number) {\n    this.#data = [];\n    this.length = length;\n    let partCount = 1;\n    while (true) {\n      partCount *= 2;\n      this.#partLength = Math.ceil(length / partCount);\n      try {\n        if (maxLengthForTesting !== undefined && this.#partLength > maxLengthForTesting) {\n          // Simulate allocation failure.\n          throw new RangeError();\n        }\n        for (let i = 0; i < partCount; ++i) {\n          this.#data[i] = new Uint32Array(this.#partLength);\n        }\n        return;\n      } catch (e) {\n        if (this.#partLength < 1e6) {\n          // The length per part is already small, so continuing to subdivide it\n          // will probably not help.\n          throw e;\n        }\n      }\n    }\n  }\n\n  getValue(index: number): number {\n    if (index >= 0 && index < this.length) {\n      const partLength = this.#partLength;\n      return this.#data[Math.floor(index / partLength)][index % partLength];\n    }\n    // On out-of-bounds accesses, match the behavior of Uint32Array: return an\n    // undefined value that's incorrectly typed as number.\n    return this.#data[0][-1];\n  }\n\n  setValue(index: number, value: number): void {\n    if (index >= 0 && index < this.length) {\n      const partLength = this.#partLength;\n      this.#data[Math.floor(index / partLength)][index % partLength] = value;\n    }\n    // Attempting to set a value out of bounds does nothing, like Uint32Array.\n  }\n\n  asUint32ArrayOrFail(): Uint32Array {\n    throw new Error('Not a Uint32Array');\n  }\n  asArrayOrFail(): number[] {\n    throw new Error('Not an array');\n  }\n}\n\nclass ExpandableBigUint32ArrayImpl extends Array<number> implements BigUint32Array {\n  getValue(index: number): number {\n    return this[index];\n  }\n  setValue(index: number, value: number): void {\n    this[index] = value;\n  }\n  asUint32ArrayOrFail(): Uint32Array {\n    throw new Error('Not a Uint32Array');\n  }\n  asArrayOrFail(): number[] {\n    return this;\n  }\n}\n","// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../platform/platform.js';\n\nconst queryParamsObject = new URLSearchParams(location.search);\n\nlet runtimePlatform = '';\n\nlet runtimeInstance: Runtime|undefined;\n\nexport function getRemoteBase(location: string = self.location.toString()): {\n  base: string,\n  version: string,\n}|null {\n  const url = new URL(location);\n  const remoteBase = url.searchParams.get('remoteBase');\n  if (!remoteBase) {\n    return null;\n  }\n\n  const version = /\\/serve_file\\/(@[0-9a-zA-Z]+)\\/?$/.exec(remoteBase);\n  if (!version) {\n    return null;\n  }\n\n  return {base: `devtools://devtools/remote/serve_file/${version[1]}/`, version: version[1]};\n}\n\nexport class Runtime {\n  private constructor() {\n  }\n\n  static instance(opts: {\n    forceNew: boolean|null,\n  }|undefined = {forceNew: null}): Runtime {\n    const {forceNew} = opts;\n    if (!runtimeInstance || forceNew) {\n      runtimeInstance = new Runtime();\n    }\n\n    return runtimeInstance;\n  }\n\n  static removeInstance(): void {\n    runtimeInstance = undefined;\n  }\n\n  static queryParam(name: string): string|null {\n    return queryParamsObject.get(name);\n  }\n\n  static setQueryParamForTesting(name: string, value: string): void {\n    queryParamsObject.set(name, value);\n  }\n\n  static experimentsSetting(): {\n    [x: string]: boolean,\n  } {\n    try {\n      return Platform.StringUtilities.toKebabCaseKeys(\n          JSON.parse(self.localStorage && self.localStorage['experiments'] ? self.localStorage['experiments'] : '{}') as\n          {\n            [x: string]: boolean,\n          });\n    } catch (e) {\n      console.error('Failed to parse localStorage[\\'experiments\\']');\n      return {};\n    }\n  }\n\n  static setPlatform(platform: string): void {\n    runtimePlatform = platform;\n  }\n\n  static platform(): string {\n    return runtimePlatform;\n  }\n\n  static isDescriptorEnabled(descriptor: {\n    experiment: ((string | undefined)|null),\n    condition?: Condition,\n  }): boolean {\n    const {experiment} = descriptor;\n    if (experiment === '*') {\n      return true;\n    }\n    if (experiment && experiment.startsWith('!') && experiments.isEnabled(experiment.substring(1))) {\n      return false;\n    }\n    if (experiment && !experiment.startsWith('!') && !experiments.isEnabled(experiment)) {\n      return false;\n    }\n    const {condition} = descriptor;\n    return condition ? condition() : true;\n  }\n\n  loadLegacyModule(modulePath: string): Promise<void> {\n    return import(`../../${modulePath}`);\n  }\n}\n\nexport interface Option {\n  title: string;\n  value: string|boolean;\n  raw?: boolean;\n  text?: string;\n}\n\nexport class ExperimentsSupport {\n  #experiments: Experiment[];\n  #experimentNames: Set<string>;\n  #enabledTransiently: Set<string>;\n  readonly #enabledByDefault: Set<string>;\n  readonly #serverEnabled: Set<string>;\n  constructor() {\n    this.#experiments = [];\n    this.#experimentNames = new Set();\n    this.#enabledTransiently = new Set();\n    this.#enabledByDefault = new Set();\n    this.#serverEnabled = new Set();\n  }\n\n  allConfigurableExperiments(): Experiment[] {\n    const result = [];\n    for (const experiment of this.#experiments) {\n      if (!this.#enabledTransiently.has(experiment.name)) {\n        result.push(experiment);\n      }\n    }\n    return result;\n  }\n\n  private setExperimentsSetting(value: Object): void {\n    if (!self.localStorage) {\n      return;\n    }\n    self.localStorage['experiments'] = JSON.stringify(value);\n  }\n\n  register(\n      experimentName: string, experimentTitle: string, unstable?: boolean, docLink?: string,\n      feedbackLink?: string): void {\n    if (this.#experimentNames.has(experimentName)) {\n      throw new Error(`Duplicate registraction of experiment '${experimentName}'`);\n    }\n    this.#experimentNames.add(experimentName);\n    this.#experiments.push(new Experiment(\n        this, experimentName, experimentTitle, Boolean(unstable),\n        docLink as Platform.DevToolsPath.UrlString ?? Platform.DevToolsPath.EmptyUrlString,\n        feedbackLink as Platform.DevToolsPath.UrlString ?? Platform.DevToolsPath.EmptyUrlString));\n  }\n\n  isEnabled(experimentName: string): boolean {\n    this.checkExperiment(experimentName);\n    // Check for explicitly disabled #experiments first - the code could call setEnable(false) on the experiment enabled\n    // by default and we should respect that.\n    if (Runtime.experimentsSetting()[experimentName] === false) {\n      return false;\n    }\n    if (this.#enabledTransiently.has(experimentName) || this.#enabledByDefault.has(experimentName)) {\n      return true;\n    }\n    if (this.#serverEnabled.has(experimentName)) {\n      return true;\n    }\n\n    return Boolean(Runtime.experimentsSetting()[experimentName]);\n  }\n\n  setEnabled(experimentName: string, enabled: boolean): void {\n    this.checkExperiment(experimentName);\n    const experimentsSetting = Runtime.experimentsSetting();\n    experimentsSetting[experimentName] = enabled;\n    this.setExperimentsSetting(experimentsSetting);\n  }\n\n  enableExperimentsTransiently(experimentNames: string[]): void {\n    for (const experimentName of experimentNames) {\n      this.checkExperiment(experimentName);\n      this.#enabledTransiently.add(experimentName);\n    }\n  }\n\n  enableExperimentsByDefault(experimentNames: string[]): void {\n    for (const experimentName of experimentNames) {\n      this.checkExperiment(experimentName);\n      this.#enabledByDefault.add(experimentName);\n    }\n  }\n\n  setServerEnabledExperiments(experimentNames: string[]): void {\n    for (const experiment of experimentNames) {\n      this.checkExperiment(experiment);\n      this.#serverEnabled.add(experiment);\n    }\n  }\n\n  enableForTest(experimentName: string): void {\n    this.checkExperiment(experimentName);\n    this.#enabledTransiently.add(experimentName);\n  }\n\n  disableForTest(experimentName: string): void {\n    this.checkExperiment(experimentName);\n    this.#enabledTransiently.delete(experimentName);\n  }\n\n  clearForTest(): void {\n    this.#experiments = [];\n    this.#experimentNames.clear();\n    this.#enabledTransiently.clear();\n    this.#enabledByDefault.clear();\n    this.#serverEnabled.clear();\n  }\n\n  cleanUpStaleExperiments(): void {\n    const experimentsSetting = Runtime.experimentsSetting();\n    const cleanedUpExperimentSetting: {\n      [x: string]: boolean,\n    } = {};\n    for (const {name: experimentName} of this.#experiments) {\n      if (experimentsSetting.hasOwnProperty(experimentName)) {\n        const isEnabled = experimentsSetting[experimentName];\n        if (isEnabled || this.#enabledByDefault.has(experimentName)) {\n          cleanedUpExperimentSetting[experimentName] = isEnabled;\n        }\n      }\n    }\n    this.setExperimentsSetting(cleanedUpExperimentSetting);\n  }\n\n  private checkExperiment(experimentName: string): void {\n    if (!this.#experimentNames.has(experimentName)) {\n      throw new Error(`Unknown experiment '${experimentName}'`);\n    }\n  }\n}\n\nexport class Experiment {\n  name: string;\n  title: string;\n  unstable: boolean;\n  docLink?: Platform.DevToolsPath.UrlString;\n  readonly feedbackLink?: Platform.DevToolsPath.UrlString;\n  readonly #experiments: ExperimentsSupport;\n  constructor(\n      experiments: ExperimentsSupport, name: string, title: string, unstable: boolean,\n      docLink: Platform.DevToolsPath.UrlString, feedbackLink: Platform.DevToolsPath.UrlString) {\n    this.name = name;\n    this.title = title;\n    this.unstable = unstable;\n    this.docLink = docLink;\n    this.feedbackLink = feedbackLink;\n    this.#experiments = experiments;\n  }\n\n  isEnabled(): boolean {\n    return this.#experiments.isEnabled(this.name);\n  }\n\n  setEnabled(enabled: boolean): void {\n    this.#experiments.setEnabled(this.name, enabled);\n  }\n}\n\n// This must be constructed after the query parameters have been parsed.\nexport const experiments = new ExperimentsSupport();\n\nexport const enum ExperimentName {\n  CAPTURE_NODE_CREATION_STACKS = 'capture-node-creation-stacks',\n  CSS_OVERVIEW = 'css-overview',\n  LIVE_HEAP_PROFILE = 'live-heap-profile',\n  ALL = '*',\n  PROTOCOL_MONITOR = 'protocol-monitor',\n  FULL_ACCESSIBILITY_TREE = 'full-accessibility-tree',\n  STYLES_PANE_CSS_CHANGES = 'styles-pane-css-changes',\n  HEADER_OVERRIDES = 'header-overrides',\n  INSTRUMENTATION_BREAKPOINTS = 'instrumentation-breakpoints',\n  AUTHORED_DEPLOYED_GROUPING = 'authored-deployed-grouping',\n  IMPORTANT_DOM_PROPERTIES = 'important-dom-properties',\n  JUST_MY_CODE = 'just-my-code',\n  PRELOADING_STATUS_PANEL = 'preloading-status-panel',\n  OUTERMOST_TARGET_SELECTOR = 'outermost-target-selector',\n  HIGHLIGHT_ERRORS_ELEMENTS_PANEL = 'highlight-errors-elements-panel',\n  USE_SOURCE_MAP_SCOPES = 'use-source-map-scopes',\n  NETWORK_PANEL_FILTER_BAR_REDESIGN = 'network-panel-filter-bar-redesign',\n  AUTOFILL_VIEW = 'autofill-view',\n  INDENTATION_MARKERS_TEMP_DISABLE = 'sources-frame-indentation-markers-temporarily-disable',\n  TIMELINE_SHOW_POST_MESSAGE_EVENTS = 'timeline-show-postmessage-events',\n  PERF_PANEL_ANNOTATIONS = 'perf-panel-annotations',\n  TIMELINE_EXTENSIONS = 'timeline-extensions',\n  TIMELINE_DEBUG_MODE = 'timeline-debug-mode',\n  TIMELINE_EXECUTE_OLD_ENGINE = 'timeline-enable-old-timeline-model-engine',\n}\n\n/**\n * When defining conditions make sure that objects used by the function have\n * been instantiated.\n */\nexport type Condition = () => boolean;\n\nexport const conditions = {\n  canDock: () => Boolean(Runtime.queryParam('can_dock')),\n};\n","// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as I18n from '../../third_party/i18n/i18n.js';\nimport type * as Platform from '../platform/platform.js';\nimport * as Root from '../root/root.js';\n\nimport {DevToolsLocale} from './DevToolsLocale.js';\nimport type * as i18nTypes from './i18nTypes.js';\nimport {\n  BUNDLED_LOCALES as BUNDLED_LOCALES_GENERATED,\n  DEFAULT_LOCALE,\n  LOCAL_FETCH_PATTERN,\n  LOCALES,\n  REMOTE_FETCH_PATTERN,\n} from './locales.js';\n\nconst i18nInstance = new I18n.I18n.I18n(LOCALES, DEFAULT_LOCALE);\n\n// All the locales that are part of the DevTools bundle and should not be fetched\n// remotely.\nconst BUNDLED_LOCALES = new Set<string>([...BUNDLED_LOCALES_GENERATED]);\n\n/**\n * Look up the best available locale for the requested language through these fall backs:\n * - exact match\n * - progressively shorter prefixes (`de-CH-1996` -> `de-CH` -> `de`)\n * - the default locale ('en-US') if no match is found\n *\n * If `locale` isn't provided, the default is used.\n */\nexport function lookupClosestSupportedDevToolsLocale(locale: string): string {\n  return i18nInstance.lookupClosestSupportedLocale(locale);\n}\n\n/**\n * Returns a list of all supported DevTools locales, including pseudo locales.\n */\nexport function getAllSupportedDevToolsLocales(): string[] {\n  return [...i18nInstance.supportedLocales];\n}\n\n/**\n * Returns the Url from which a locale can be fetched. This depends on the\n * specific locale, as some are bundled with DevTools while others\n * have to be fetched remotely.\n */\nfunction getLocaleFetchUrl(locale: Intl.UnicodeBCP47LocaleIdentifier, location: string): string {\n  const remoteBase = Root.Runtime.getRemoteBase(location);\n  if (remoteBase && remoteBase.version && !BUNDLED_LOCALES.has(locale)) {\n    return REMOTE_FETCH_PATTERN.replace('@HOST@', 'devtools://devtools')\n        .replace('@VERSION@', remoteBase.version)\n        .replace('@LOCALE@', locale);\n  }\n  const path = LOCAL_FETCH_PATTERN.replace('@LOCALE@', locale);\n  return new URL(path, import.meta.url).toString();\n}\n\n/**\n * Fetches the locale data of the specified locale.\n * Callers have to ensure that `locale` is an officilly supported locale.\n * Depending whether a locale is present in `bundledLocales`, the data will be\n * fetched locally or remotely.\n */\nexport async function fetchAndRegisterLocaleData(\n    locale: Intl.UnicodeBCP47LocaleIdentifier, location = self.location.toString()): Promise<void> {\n  const localeDataTextPromise = fetch(getLocaleFetchUrl(locale, location)).then(result => result.json());\n  const timeoutPromise =\n      new Promise((resolve, reject) => window.setTimeout(() => reject(new Error('timed out fetching locale')), 5000));\n  const localeData = await Promise.race([timeoutPromise, localeDataTextPromise]);\n  i18nInstance.registerLocaleData(locale, localeData);\n}\n\n/**\n * Returns an anonymous function that wraps a call to retrieve a localized string.\n * This is introduced so that localized strings can be declared in environments where\n * the i18n system has not been configured and so, cannot be directly invoked. Instead,\n * strings are lazily localized when they are used. This is used for instance in the\n * meta files used to register module extensions.\n */\nexport function getLazilyComputedLocalizedString(\n    registeredStrings: I18n.LocalizedStringSet.RegisteredFileStrings, id: string, values: i18nTypes.Values = {}): () =>\n    Platform.UIString.LocalizedString {\n  return (): Platform.UIString.LocalizedString => getLocalizedString(registeredStrings, id, values);\n}\n\n/**\n * Retrieve the localized string.\n */\nexport function getLocalizedString(\n    registeredStrings: I18n.LocalizedStringSet.RegisteredFileStrings, id: string,\n    values: i18nTypes.Values = {}): Platform.UIString.LocalizedString {\n  return registeredStrings.getLocalizedStringSetFor(DevToolsLocale.instance().locale).getLocalizedString(id, values) as\n      Platform.UIString.LocalizedString;\n}\n\n/**\n * Register a file's UIStrings with i18n, return function to generate the string ids.\n */\nexport function registerUIStrings(\n    path: string, stringStructure: {[key: string]: string}): I18n.LocalizedStringSet.RegisteredFileStrings {\n  return i18nInstance.registerFileStrings(path, stringStructure);\n}\n\n/**\n * Returns a span element that may contains other DOM element as placeholders\n */\nexport function getFormatLocalizedString(\n    registeredStrings: I18n.LocalizedStringSet.RegisteredFileStrings, stringId: string,\n    placeholders: Record<string, Object>): Element {\n  const formatter =\n      registeredStrings.getLocalizedStringSetFor(DevToolsLocale.instance().locale).getMessageFormatterFor(stringId);\n\n  const element = document.createElement('span');\n  for (const icuElement of formatter.getAst()) {\n    if (icuElement.type === /* argumentElement */ 1) {\n      const placeholderValue = placeholders[icuElement.value];\n      if (placeholderValue) {\n        element.append(placeholderValue as Node | string);\n      }\n    } else if ('value' in icuElement) {\n      element.append(String(icuElement.value));\n    }\n  }\n  return element;\n}\n\nexport function serializeUIString(string: string, values: Record<string, Object> = {}): string {\n  const serializedMessage = {string, values};\n  return JSON.stringify(serializedMessage);\n}\n\nexport function deserializeUIString(serializedMessage: string): i18nTypes.SerializedMessage {\n  if (!serializedMessage) {\n    return {string: '', values: {}} as i18nTypes.SerializedMessage;\n  }\n\n  return JSON.parse(serializedMessage) as i18nTypes.SerializedMessage;\n}\n\n/**\n * Use this function in places where a `LocalizedString` is expected but the\n * term/phrase you want to use does not require translation.\n */\nexport function lockedString(str: string): Platform.UIString.LocalizedString {\n  return str as Platform.UIString.LocalizedString;\n}\n\n/**\n * Same as `lockedString` but for places where `i18nLazyString` would be used otherwise.\n */\nexport function lockedLazyString(str: string): () => Platform.UIString.LocalizedString {\n  return (): Platform.UIString.LocalizedString => str as Platform.UIString.LocalizedString;\n}\n\n/**\n * Returns a string of the form:\n *   \"German (Austria) - Deutsch (sterreich)\"\n * where the former locale representation is written in the currently enabled DevTools\n * locale and the latter locale representation is written in the locale of `localeString`.\n *\n * Should the two locales match (i.e. have the same language) then the latter locale\n * representation is written in English.\n */\nexport function getLocalizedLanguageRegion(\n    localeString: Intl.UnicodeBCP47LocaleIdentifier,\n    devtoolsLocale: DevToolsLocale): Platform.UIString.LocalizedString {\n  const locale = new Intl.Locale(localeString);\n  const {language, baseName} = locale;\n  const devtoolsLoc = new Intl.Locale(devtoolsLocale.locale);\n  const targetLanguage = language === devtoolsLoc.language ? 'en' : baseName;\n  const languageInCurrentLocale = new Intl.DisplayNames([devtoolsLocale.locale], {type: 'language'}).of(language);\n  const languageInTargetLocale = new Intl.DisplayNames([targetLanguage], {type: 'language'}).of(language);\n\n  let wrappedRegionInCurrentLocale = '';\n  let wrappedRegionInTargetLocale = '';\n\n  if (locale.region) {\n    const regionInCurrentLocale =\n        new Intl.DisplayNames([devtoolsLocale.locale], {type: 'region', style: 'short'}).of(locale.region);\n    const regionInTargetLocale =\n        new Intl.DisplayNames([targetLanguage], {type: 'region', style: 'short'}).of(locale.region);\n    wrappedRegionInCurrentLocale = ` (${regionInCurrentLocale})`;\n    wrappedRegionInTargetLocale = ` (${regionInTargetLocale})`;\n  }\n\n  return `${languageInCurrentLocale}${wrappedRegionInCurrentLocale} - ${languageInTargetLocale}${\n             wrappedRegionInTargetLocale}` as Platform.UIString.LocalizedString;\n}\n","// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {getLocalizedString, registerUIStrings} from './i18nImpl.js';\n\nconst UIStrings = {\n  /**\n   *@description s is the short form of micro-seconds and the placeholder is a number\n   *@example {2} PH1\n   */\n  fmms: '{PH1}s',\n  /**\n   *@description ms is the short form of milli-seconds and the placeholder is a decimal number\n   *@example {2.14} PH1\n   */\n  fms: '{PH1}ms',\n  /**\n   *@description s is short for seconds and the placeholder is a decimal number\n   *@example {2.14} PH1\n   */\n  fs: '{PH1}s',\n  /**\n   *@description min is short for minutes and the placeholder is a decimal number\n   *@example {2.2} PH1\n   */\n  fmin: '{PH1}min',\n  /**\n   *@description hrs is short for hours and the placeholder is a decimal number\n   *@example {2.2} PH1\n   */\n  fhrs: '{PH1}hrs',\n  /**\n   *@description days formatting and the placeholder is a decimal number\n   *@example {2.2} PH1\n   */\n  fdays: '{PH1}days',\n};\n\nconst str_ = registerUIStrings('core/i18n/time-utilities.ts', UIStrings);\nconst i18nString = getLocalizedString.bind(undefined, str_);\n\nexport const preciseMillisToString = function(ms: number, precision?: number): string {\n  precision = precision || 0;\n  return i18nString(UIStrings.fms, {PH1: ms.toFixed(precision)});\n};\n\nexport const millisToString = function(ms: number, higherResolution?: boolean): string {\n  if (!isFinite(ms)) {\n    return '-';\n  }\n\n  if (ms === 0) {\n    return '0';\n  }\n\n  if (higherResolution && ms < 0.1) {\n    return i18nString(UIStrings.fmms, {PH1: (ms * 1000).toFixed(0)});\n  }\n  if (higherResolution && ms < 1000) {\n    return i18nString(UIStrings.fms, {PH1: (ms).toFixed(2)});\n  }\n  if (ms < 1000) {\n    return i18nString(UIStrings.fms, {PH1: (ms).toFixed(0)});\n  }\n\n  const seconds = ms / 1000;\n  if (seconds < 60) {\n    return i18nString(UIStrings.fs, {PH1: (seconds).toFixed(2)});\n  }\n\n  const minutes = seconds / 60;\n  if (minutes < 60) {\n    return i18nString(UIStrings.fmin, {PH1: (minutes).toFixed(1)});\n  }\n\n  const hours = minutes / 60;\n  if (hours < 24) {\n    return i18nString(UIStrings.fhrs, {PH1: (hours).toFixed(1)});\n  }\n\n  const days = hours / 24;\n  return i18nString(UIStrings.fdays, {PH1: (days).toFixed(1)});\n};\n\nexport const secondsToString = function(seconds: number, higherResolution?: boolean): string {\n  if (!isFinite(seconds)) {\n    return '-';\n  }\n  return millisToString(seconds * 1000, higherResolution);\n};\n","/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* eslint-disable rulesdir/use_private_class_members */\n\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\n\nimport {AllocationProfile} from './AllocationProfile.js';\nimport {type HeapSnapshotWorkerDispatcher} from './HeapSnapshotWorkerDispatcher.js';\n\nexport interface HeapSnapshotItem {\n  itemIndex(): number;\n\n  serialize(): Object;\n}\n\nexport class HeapSnapshotEdge implements HeapSnapshotItem {\n  snapshot: HeapSnapshot;\n  protected readonly edges: Platform.TypedArrayUtilities.BigUint32Array;\n  edgeIndex: number;\n  constructor(snapshot: HeapSnapshot, edgeIndex?: number) {\n    this.snapshot = snapshot;\n    this.edges = snapshot.containmentEdges;\n    this.edgeIndex = edgeIndex || 0;\n  }\n\n  clone(): HeapSnapshotEdge {\n    return new HeapSnapshotEdge(this.snapshot, this.edgeIndex);\n  }\n\n  hasStringName(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  name(): string {\n    throw new Error('Not implemented');\n  }\n\n  node(): HeapSnapshotNode {\n    return this.snapshot.createNode(this.nodeIndex());\n  }\n\n  nodeIndex(): number {\n    if (typeof this.snapshot.edgeToNodeOffset === 'undefined') {\n      throw new Error('edgeToNodeOffset is undefined');\n    }\n\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeToNodeOffset);\n  }\n\n  toString(): string {\n    return 'HeapSnapshotEdge: ' + this.name();\n  }\n\n  type(): string {\n    return this.snapshot.edgeTypes[this.rawType()];\n  }\n\n  itemIndex(): number {\n    return this.edgeIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Edge {\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), this.node().serialize(), this.type(), this.edgeIndex);\n  }\n\n  rawType(): number {\n    if (typeof this.snapshot.edgeTypeOffset === 'undefined') {\n      throw new Error('edgeTypeOffset is undefined');\n    }\n\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeTypeOffset);\n  }\n\n  isInternal(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isInvisible(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isWeak(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  getValueForSorting(_fieldName: string): number {\n    throw new Error('Not implemented');\n  }\n}\n\nexport interface HeapSnapshotItemIterator {\n  hasNext(): boolean;\n\n  item(): HeapSnapshotItem;\n\n  next(): void;\n}\n\nexport interface HeapSnapshotItemIndexProvider {\n  itemForIndex(newIndex: number): HeapSnapshotItem;\n}\n\nexport class HeapSnapshotNodeIndexProvider implements HeapSnapshotItemIndexProvider {\n  #node: HeapSnapshotNode;\n  constructor(snapshot: HeapSnapshot) {\n    this.#node = snapshot.createNode();\n  }\n\n  itemForIndex(index: number): HeapSnapshotNode {\n    this.#node.nodeIndex = index;\n    return this.#node;\n  }\n}\n\nexport class HeapSnapshotEdgeIndexProvider implements HeapSnapshotItemIndexProvider {\n  #edge: JSHeapSnapshotEdge;\n  constructor(snapshot: HeapSnapshot) {\n    this.#edge = snapshot.createEdge(0);\n  }\n\n  itemForIndex(index: number): HeapSnapshotEdge {\n    this.#edge.edgeIndex = index;\n    return this.#edge;\n  }\n}\n\nexport class HeapSnapshotRetainerEdgeIndexProvider implements HeapSnapshotItemIndexProvider {\n  readonly #retainerEdge: JSHeapSnapshotRetainerEdge;\n  constructor(snapshot: HeapSnapshot) {\n    this.#retainerEdge = snapshot.createRetainingEdge(0);\n  }\n\n  itemForIndex(index: number): HeapSnapshotRetainerEdge {\n    this.#retainerEdge.setRetainerIndex(index);\n    return this.#retainerEdge;\n  }\n}\n\nexport class HeapSnapshotEdgeIterator implements HeapSnapshotItemIterator {\n  readonly #sourceNode: HeapSnapshotNode;\n  edge: JSHeapSnapshotEdge;\n  constructor(node: HeapSnapshotNode) {\n    this.#sourceNode = node;\n    this.edge = node.snapshot.createEdge(node.edgeIndexesStart());\n  }\n\n  hasNext(): boolean {\n    return this.edge.edgeIndex < this.#sourceNode.edgeIndexesEnd();\n  }\n\n  item(): HeapSnapshotEdge {\n    return this.edge;\n  }\n\n  next(): void {\n    if (typeof this.edge.snapshot.edgeFieldsCount === 'undefined') {\n      throw new Error('edgeFieldsCount is undefined');\n    }\n    this.edge.edgeIndex += this.edge.snapshot.edgeFieldsCount;\n  }\n}\n\nexport class HeapSnapshotRetainerEdge implements HeapSnapshotItem {\n  protected snapshot: HeapSnapshot;\n  #retainerIndexInternal!: number;\n  #globalEdgeIndex!: number;\n  #retainingNodeIndex?: number;\n  #edgeInstance?: JSHeapSnapshotEdge|null;\n  #nodeInstance?: HeapSnapshotNode|null;\n  constructor(snapshot: HeapSnapshot, retainerIndex: number) {\n    this.snapshot = snapshot;\n    this.setRetainerIndex(retainerIndex);\n  }\n\n  clone(): HeapSnapshotRetainerEdge {\n    return new HeapSnapshotRetainerEdge(this.snapshot, this.retainerIndex());\n  }\n\n  hasStringName(): boolean {\n    return this.edge().hasStringName();\n  }\n\n  name(): string {\n    return this.edge().name();\n  }\n\n  node(): HeapSnapshotNode {\n    return this.nodeInternal();\n  }\n\n  nodeIndex(): number {\n    if (typeof this.#retainingNodeIndex === 'undefined') {\n      throw new Error('retainingNodeIndex is undefined');\n    }\n\n    return this.#retainingNodeIndex;\n  }\n\n  retainerIndex(): number {\n    return this.#retainerIndexInternal;\n  }\n\n  setRetainerIndex(retainerIndex: number): void {\n    if (retainerIndex === this.#retainerIndexInternal) {\n      return;\n    }\n\n    if (!this.snapshot.retainingEdges || !this.snapshot.retainingNodes) {\n      throw new Error('Snapshot does not contain retaining edges or retaining nodes');\n    }\n\n    this.#retainerIndexInternal = retainerIndex;\n    this.#globalEdgeIndex = this.snapshot.retainingEdges[retainerIndex];\n    this.#retainingNodeIndex = this.snapshot.retainingNodes[retainerIndex];\n    this.#edgeInstance = null;\n    this.#nodeInstance = null;\n  }\n\n  set edgeIndex(edgeIndex: number) {\n    this.setRetainerIndex(edgeIndex);\n  }\n\n  private nodeInternal(): HeapSnapshotNode {\n    if (!this.#nodeInstance) {\n      this.#nodeInstance = this.snapshot.createNode(this.#retainingNodeIndex);\n    }\n    return this.#nodeInstance;\n  }\n\n  protected edge(): JSHeapSnapshotEdge {\n    if (!this.#edgeInstance) {\n      this.#edgeInstance = this.snapshot.createEdge(this.#globalEdgeIndex);\n    }\n    return this.#edgeInstance;\n  }\n\n  toString(): string {\n    return this.edge().toString();\n  }\n\n  itemIndex(): number {\n    return this.#retainerIndexInternal;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Edge {\n    const node = this.node();\n    const serializedNode = node.serialize();\n    serializedNode.distance = this.#distance();\n    serializedNode.ignored = this.snapshot.isNodeIgnoredInRetainersView(node.nodeIndex);\n\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), serializedNode, this.type(), this.#globalEdgeIndex);\n  }\n\n  type(): string {\n    return this.edge().type();\n  }\n\n  isInternal(): boolean {\n    return this.edge().isInternal();\n  }\n\n  getValueForSorting(fieldName: string): number {\n    if (fieldName === '!edgeDistance') {\n      return this.#distance();\n    }\n    throw new Error('Invalid field name');\n  }\n\n  #distance(): number {\n    if (this.snapshot.isEdgeIgnoredInRetainersView(this.#globalEdgeIndex)) {\n      return HeapSnapshotModel.HeapSnapshotModel.baseUnreachableDistance;\n    }\n    return this.node().distanceForRetainersView();\n  }\n}\n\nexport class HeapSnapshotRetainerEdgeIterator implements HeapSnapshotItemIterator {\n  readonly #retainersEnd: number;\n  retainer: JSHeapSnapshotRetainerEdge;\n  constructor(retainedNode: HeapSnapshotNode) {\n    const snapshot = retainedNode.snapshot;\n    const retainedNodeOrdinal = retainedNode.ordinal();\n    if (!snapshot.firstRetainerIndex) {\n      throw new Error('Snapshot does not contain firstRetainerIndex');\n    }\n    const retainerIndex = snapshot.firstRetainerIndex[retainedNodeOrdinal];\n    this.#retainersEnd = snapshot.firstRetainerIndex[retainedNodeOrdinal + 1];\n    this.retainer = snapshot.createRetainingEdge(retainerIndex);\n  }\n\n  hasNext(): boolean {\n    return this.retainer.retainerIndex() < this.#retainersEnd;\n  }\n\n  item(): HeapSnapshotRetainerEdge {\n    return this.retainer;\n  }\n\n  next(): void {\n    this.retainer.setRetainerIndex(this.retainer.retainerIndex() + 1);\n  }\n}\n\nexport class HeapSnapshotNode implements HeapSnapshotItem {\n  snapshot: HeapSnapshot;\n  nodeIndex: number;\n  constructor(snapshot: HeapSnapshot, nodeIndex?: number) {\n    this.snapshot = snapshot;\n    this.nodeIndex = nodeIndex || 0;\n  }\n\n  distance(): number {\n    return this.snapshot.nodeDistances[this.nodeIndex / this.snapshot.nodeFieldCount];\n  }\n\n  distanceForRetainersView(): number {\n    return this.snapshot.getDistanceForRetainersView(this.nodeIndex);\n  }\n\n  className(): string {\n    throw new Error('Not implemented');\n  }\n\n  classIndex(): number {\n    throw new Error('Not implemented');\n  }\n\n  dominatorIndex(): number {\n    const nodeFieldCount = this.snapshot.nodeFieldCount;\n    return this.snapshot.dominatorsTree[this.nodeIndex / this.snapshot.nodeFieldCount] * nodeFieldCount;\n  }\n\n  edges(): HeapSnapshotEdgeIterator {\n    return new HeapSnapshotEdgeIterator(this);\n  }\n\n  edgesCount(): number {\n    return (this.edgeIndexesEnd() - this.edgeIndexesStart()) / this.snapshot.edgeFieldsCount;\n  }\n\n  id(): number {\n    throw new Error('Not implemented');\n  }\n\n  rawName(): string {\n    throw new Error('Not implemented');\n  }\n\n  isRoot(): boolean {\n    return this.nodeIndex === this.snapshot.rootNodeIndex;\n  }\n\n  isUserRoot(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isHidden(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isArray(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isSynthetic(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isDocumentDOMTreesRoot(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  name(): string {\n    return this.snapshot.strings[this.nameInternal()];\n  }\n\n  retainedSize(): number {\n    return this.snapshot.retainedSizes[this.ordinal()];\n  }\n\n  retainers(): HeapSnapshotRetainerEdgeIterator {\n    return new HeapSnapshotRetainerEdgeIterator(this);\n  }\n\n  retainersCount(): number {\n    const snapshot = this.snapshot;\n    const ordinal = this.ordinal();\n    return snapshot.firstRetainerIndex[ordinal + 1] - snapshot.firstRetainerIndex[ordinal];\n  }\n\n  selfSize(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeSelfSizeOffset);\n  }\n\n  type(): string {\n    return this.snapshot.nodeTypes[this.rawType()];\n  }\n\n  traceNodeId(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeTraceNodeIdOffset);\n  }\n\n  itemIndex(): number {\n    return this.nodeIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Node {\n    return new HeapSnapshotModel.HeapSnapshotModel.Node(\n        this.id(), this.name(), this.distance(), this.nodeIndex, this.retainedSize(), this.selfSize(), this.type());\n  }\n\n  private nameInternal(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeNameOffset);\n  }\n\n  edgeIndexesStart(): number {\n    return this.snapshot.firstEdgeIndexes[this.ordinal()];\n  }\n\n  edgeIndexesEnd(): number {\n    return this.snapshot.firstEdgeIndexes[this.ordinal() + 1];\n  }\n\n  ordinal(): number {\n    return this.nodeIndex / this.snapshot.nodeFieldCount;\n  }\n\n  nextNodeIndex(): number {\n    return this.nodeIndex + this.snapshot.nodeFieldCount;\n  }\n\n  rawType(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeTypeOffset);\n  }\n\n  isFlatConsString(): boolean {\n    if (this.rawType() !== this.snapshot.nodeConsStringType) {\n      return false;\n    }\n    for (let iter = this.edges(); iter.hasNext(); iter.next()) {\n      const edge = iter.edge;\n      if (!edge.isInternal()) {\n        continue;\n      }\n      const edgeName = edge.name();\n      if ((edgeName === 'first' || edgeName === 'second') && edge.node().name() === '') {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nexport class HeapSnapshotNodeIterator implements HeapSnapshotItemIterator {\n  node: HeapSnapshotNode;\n  readonly #nodesLength: number;\n  constructor(node: HeapSnapshotNode) {\n    this.node = node;\n    this.#nodesLength = node.snapshot.nodes.length;\n  }\n\n  hasNext(): boolean {\n    return this.node.nodeIndex < this.#nodesLength;\n  }\n\n  item(): HeapSnapshotNode {\n    return this.node;\n  }\n\n  next(): void {\n    this.node.nodeIndex = this.node.nextNodeIndex();\n  }\n}\n\nexport class HeapSnapshotIndexRangeIterator implements HeapSnapshotItemIterator {\n  readonly #itemProvider: HeapSnapshotItemIndexProvider;\n  readonly #indexes: number[]|Uint32Array;\n  #position: number;\n  constructor(itemProvider: HeapSnapshotItemIndexProvider, indexes: number[]|Uint32Array) {\n    this.#itemProvider = itemProvider;\n    this.#indexes = indexes;\n    this.#position = 0;\n  }\n\n  hasNext(): boolean {\n    return this.#position < this.#indexes.length;\n  }\n\n  item(): HeapSnapshotItem {\n    const index = this.#indexes[this.#position];\n    return this.#itemProvider.itemForIndex(index);\n  }\n\n  next(): void {\n    ++this.#position;\n  }\n}\n\nexport class HeapSnapshotFilteredIterator implements HeapSnapshotItemIterator {\n  #iterator: HeapSnapshotItemIterator;\n  #filter: ((arg0: HeapSnapshotItem) => boolean)|undefined;\n  constructor(iterator: HeapSnapshotItemIterator, filter?: ((arg0: HeapSnapshotItem) => boolean)) {\n    this.#iterator = iterator;\n    this.#filter = filter;\n    this.skipFilteredItems();\n  }\n\n  hasNext(): boolean {\n    return this.#iterator.hasNext();\n  }\n\n  item(): HeapSnapshotItem {\n    return this.#iterator.item();\n  }\n\n  next(): void {\n    this.#iterator.next();\n    this.skipFilteredItems();\n  }\n\n  private skipFilteredItems(): void {\n    while (this.#iterator.hasNext() && this.#filter && !this.#filter(this.#iterator.item())) {\n      this.#iterator.next();\n    }\n  }\n}\n\nexport class HeapSnapshotProgress {\n  readonly #dispatcher: HeapSnapshotWorkerDispatcher|undefined;\n  constructor(dispatcher?: HeapSnapshotWorkerDispatcher) {\n    this.#dispatcher = dispatcher;\n  }\n\n  updateStatus(status: string): void {\n    this.sendUpdateEvent(i18n.i18n.serializeUIString(status));\n  }\n\n  updateProgress(title: string, value: number, total: number): void {\n    const percentValue = ((total ? (value / total) : 0) * 100).toFixed(0);\n    this.sendUpdateEvent(i18n.i18n.serializeUIString(title, {PH1: percentValue}));\n  }\n\n  reportProblem(error: string): void {\n    // May be undefined in tests.\n    if (this.#dispatcher) {\n      this.#dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.BrokenSnapshot, error);\n    }\n  }\n\n  private sendUpdateEvent(serializedText: string): void {\n    // May be undefined in tests.\n    if (this.#dispatcher) {\n      this.#dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.Update, serializedText);\n    }\n  }\n}\n\nexport class HeapSnapshotProblemReport {\n  readonly #errors: string[];\n  constructor(title: string) {\n    this.#errors = [title];\n  }\n\n  addError(error: string): void {\n    if (this.#errors.length > 100) {\n      return;\n    }\n    this.#errors.push(error);\n  }\n\n  toString(): string {\n    return this.#errors.join('\\n  ');\n  }\n}\nexport interface Profile {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  root_index: number;\n  nodes: Platform.TypedArrayUtilities.BigUint32Array;\n  edges: Platform.TypedArrayUtilities.BigUint32Array;\n  snapshot: HeapSnapshotHeader;\n  samples: number[];\n  strings: string[];\n  locations: number[];\n  trace_function_infos: Uint32Array;\n  trace_tree: Object;\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport interface LiveObjects {\n  [x: number]: {count: number, size: number, ids: number[]};\n}\n\n/**\n * DOM node link state.\n */\nconst enum DOMLinkState {\n  Unknown = 0,\n  Attached = 1,\n  Detached = 2,\n}\n\nexport abstract class HeapSnapshot {\n  nodes: Platform.TypedArrayUtilities.BigUint32Array;\n  containmentEdges: Platform.TypedArrayUtilities.BigUint32Array;\n  readonly #metaNode: HeapSnapshotMetainfo;\n  readonly #rawSamples: number[];\n  #samples: HeapSnapshotModel.HeapSnapshotModel.Samples|null;\n  strings: string[];\n  readonly #locations: number[];\n  readonly #progress: HeapSnapshotProgress;\n  readonly #noDistance: number;\n  rootNodeIndexInternal: number;\n  #snapshotDiffs: {\n    [x: string]: {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff,\n    },\n  };\n  #aggregatesForDiffInternal!: {\n    [x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff,\n  };\n  #aggregates: {\n    [x: string]: {\n      [x: string]: AggregatedInfo,\n    },\n  };\n  #aggregatesSortedFlags: {\n    [x: string]: boolean,\n  };\n  #profile: Profile;\n  nodeTypeOffset!: number;\n  nodeNameOffset!: number;\n  nodeIdOffset!: number;\n  nodeSelfSizeOffset!: number;\n  #nodeEdgeCountOffset!: number;\n  nodeTraceNodeIdOffset!: number;\n  nodeFieldCount!: number;\n  nodeTypes!: string[];\n  nodeArrayType!: number;\n  nodeHiddenType!: number;\n  nodeObjectType!: number;\n  nodeNativeType!: number;\n  nodeStringType!: number;\n  nodeConsStringType!: number;\n  nodeSlicedStringType!: number;\n  nodeCodeType!: number;\n  nodeSyntheticType!: number;\n  edgeFieldsCount!: number;\n  edgeTypeOffset!: number;\n  edgeNameOffset!: number;\n  edgeToNodeOffset!: number;\n  edgeTypes!: string[];\n  edgeElementType!: number;\n  edgeHiddenType!: number;\n  edgeInternalType!: number;\n  edgeShortcutType!: number;\n  edgeWeakType!: number;\n  edgeInvisibleType!: number;\n  #locationIndexOffset!: number;\n  #locationScriptIdOffset!: number;\n  #locationLineOffset!: number;\n  #locationColumnOffset!: number;\n  #locationFieldCount!: number;\n  nodeCount!: number;\n  #edgeCount!: number;\n  retainedSizes!: Float64Array;\n  firstEdgeIndexes!: Uint32Array;\n  retainingNodes!: Uint32Array;\n  retainingEdges!: Uint32Array;\n  firstRetainerIndex!: Uint32Array;\n  nodeDistances!: Int32Array;\n  firstDominatedNodeIndex!: Uint32Array;\n  dominatedNodes!: Uint32Array;\n  dominatorsTree!: Uint32Array;\n  #allocationProfile!: AllocationProfile;\n  #nodeDetachednessOffset!: number;\n  #locationMap!: Map<number, HeapSnapshotModel.HeapSnapshotModel.Location>;\n  lazyStringCache!: {\n    [x: string]: string,\n  };\n  #ignoredNodesInRetainersView: Set<number>;\n  #ignoredEdgesInRetainersView: Set<number>;\n  #nodeDistancesForRetainersView: Int32Array|undefined;\n\n  constructor(profile: Profile, progress: HeapSnapshotProgress) {\n    this.nodes = profile.nodes;\n    this.containmentEdges = profile.edges;\n    this.#metaNode = profile.snapshot.meta;\n    this.#rawSamples = profile.samples;\n    this.#samples = null;\n    this.strings = profile.strings;\n    this.#locations = profile.locations;\n    this.#progress = progress;\n\n    this.#noDistance = -5;\n    this.rootNodeIndexInternal = 0;\n    if (profile.snapshot.root_index) {\n      this.rootNodeIndexInternal = profile.snapshot.root_index;\n    }\n\n    this.#snapshotDiffs = {};\n\n    this.#aggregates = {};\n\n    this.#aggregatesSortedFlags = {};\n    this.#profile = profile;\n    this.#ignoredNodesInRetainersView = new Set();\n    this.#ignoredEdgesInRetainersView = new Set();\n  }\n\n  initialize(): void {\n    const meta = this.#metaNode;\n\n    this.nodeTypeOffset = meta.node_fields.indexOf('type');\n    this.nodeNameOffset = meta.node_fields.indexOf('name');\n    this.nodeIdOffset = meta.node_fields.indexOf('id');\n    this.nodeSelfSizeOffset = meta.node_fields.indexOf('self_size');\n    this.#nodeEdgeCountOffset = meta.node_fields.indexOf('edge_count');\n    this.nodeTraceNodeIdOffset = meta.node_fields.indexOf('trace_node_id');\n    this.#nodeDetachednessOffset = meta.node_fields.indexOf('detachedness');\n    this.nodeFieldCount = meta.node_fields.length;\n\n    this.nodeTypes = meta.node_types[this.nodeTypeOffset];\n    this.nodeArrayType = this.nodeTypes.indexOf('array');\n    this.nodeHiddenType = this.nodeTypes.indexOf('hidden');\n    this.nodeObjectType = this.nodeTypes.indexOf('object');\n    this.nodeNativeType = this.nodeTypes.indexOf('native');\n    this.nodeStringType = this.nodeTypes.indexOf('string');\n    this.nodeConsStringType = this.nodeTypes.indexOf('concatenated string');\n    this.nodeSlicedStringType = this.nodeTypes.indexOf('sliced string');\n    this.nodeCodeType = this.nodeTypes.indexOf('code');\n    this.nodeSyntheticType = this.nodeTypes.indexOf('synthetic');\n\n    this.edgeFieldsCount = meta.edge_fields.length;\n    this.edgeTypeOffset = meta.edge_fields.indexOf('type');\n    this.edgeNameOffset = meta.edge_fields.indexOf('name_or_index');\n    this.edgeToNodeOffset = meta.edge_fields.indexOf('to_node');\n\n    this.edgeTypes = meta.edge_types[this.edgeTypeOffset];\n    this.edgeTypes.push('invisible');\n    this.edgeElementType = this.edgeTypes.indexOf('element');\n    this.edgeHiddenType = this.edgeTypes.indexOf('hidden');\n    this.edgeInternalType = this.edgeTypes.indexOf('internal');\n    this.edgeShortcutType = this.edgeTypes.indexOf('shortcut');\n    this.edgeWeakType = this.edgeTypes.indexOf('weak');\n    this.edgeInvisibleType = this.edgeTypes.indexOf('invisible');\n\n    const locationFields = meta.location_fields || [];\n\n    this.#locationIndexOffset = locationFields.indexOf('object_index');\n    this.#locationScriptIdOffset = locationFields.indexOf('script_id');\n    this.#locationLineOffset = locationFields.indexOf('line');\n    this.#locationColumnOffset = locationFields.indexOf('column');\n    this.#locationFieldCount = locationFields.length;\n\n    this.nodeCount = this.nodes.length / this.nodeFieldCount;\n    this.#edgeCount = this.containmentEdges.length / this.edgeFieldsCount;\n\n    this.retainedSizes = new Float64Array(this.nodeCount);\n    this.firstEdgeIndexes = new Uint32Array(this.nodeCount + 1);\n    this.retainingNodes = new Uint32Array(this.#edgeCount);\n    this.retainingEdges = new Uint32Array(this.#edgeCount);\n    this.firstRetainerIndex = new Uint32Array(this.nodeCount + 1);\n    this.nodeDistances = new Int32Array(this.nodeCount);\n    this.firstDominatedNodeIndex = new Uint32Array(this.nodeCount + 1);\n    this.dominatedNodes = new Uint32Array(this.nodeCount - 1);\n\n    this.#progress.updateStatus('Building edge indexes');\n    this.buildEdgeIndexes();\n    this.#progress.updateStatus('Building retainers');\n    this.buildRetainers();\n    this.#progress.updateStatus('Propagating DOM state');\n    this.propagateDOMState();\n    this.#progress.updateStatus('Calculating node flags');\n    this.calculateFlags();\n    this.#progress.updateStatus('Calculating distances');\n    this.calculateDistances(/* isForRetainersView=*/ false);\n    this.#progress.updateStatus('Building postorder index');\n    const result = this.buildPostOrderIndex();\n    // Actually it is array that maps node ordinal number to dominator node ordinal number.\n    this.#progress.updateStatus('Building dominator tree');\n    this.dominatorsTree = this.buildDominatorTree(result.postOrderIndex2NodeOrdinal, result.nodeOrdinal2PostOrderIndex);\n    this.#progress.updateStatus('Calculating shallow sizes');\n    this.calculateShallowSizes();\n    this.#progress.updateStatus('Calculating retained sizes');\n    this.calculateRetainedSizes(result.postOrderIndex2NodeOrdinal);\n    this.#progress.updateStatus('Building dominated nodes');\n    this.buildDominatedNodes();\n    this.#progress.updateStatus('Calculating statistics');\n    this.calculateStatistics();\n    this.#progress.updateStatus('Calculating samples');\n    this.buildSamples();\n    this.#progress.updateStatus('Building locations');\n    this.buildLocationMap();\n    this.#progress.updateStatus('Finished processing.');\n\n    if (this.#profile.snapshot.trace_function_count) {\n      this.#progress.updateStatus('Building allocation statistics');\n      const nodes = this.nodes;\n      const nodesLength = nodes.length;\n      const nodeFieldCount = this.nodeFieldCount;\n      const node = this.rootNode();\n      const liveObjects: LiveObjects = {};\n      for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n        node.nodeIndex = nodeIndex;\n        const traceNodeId = node.traceNodeId();\n        let stats: {\n          count: number,\n          size: number,\n          ids: number[],\n        } = liveObjects[traceNodeId];\n        if (!stats) {\n          liveObjects[traceNodeId] = stats = {count: 0, size: 0, ids: []};\n        }\n        stats.count++;\n        stats.size += node.selfSize();\n        stats.ids.push(node.id());\n      }\n      this.#allocationProfile = new AllocationProfile(this.#profile, liveObjects);\n      this.#progress.updateStatus('done');\n    }\n  }\n\n  private buildEdgeIndexes(): void {\n    const nodes = this.nodes;\n    const nodeCount = this.nodeCount;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const nodeFieldCount = this.nodeFieldCount;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const nodeEdgeCountOffset = this.#nodeEdgeCountOffset;\n    firstEdgeIndexes[nodeCount] = this.containmentEdges.length;\n    for (let nodeOrdinal = 0, edgeIndex = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      firstEdgeIndexes[nodeOrdinal] = edgeIndex;\n      edgeIndex += nodes.getValue(nodeOrdinal * nodeFieldCount + nodeEdgeCountOffset) * edgeFieldsCount;\n    }\n  }\n\n  private buildRetainers(): void {\n    const retainingNodes = this.retainingNodes;\n    const retainingEdges = this.retainingEdges;\n    // Index of the first retainer in the retainingNodes and retainingEdges\n    // arrays. Addressed by retained node index.\n    const firstRetainerIndex = this.firstRetainerIndex;\n\n    const containmentEdges = this.containmentEdges;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const nodeFieldCount = this.nodeFieldCount;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const nodeCount = this.nodeCount;\n\n    for (let toNodeFieldIndex = edgeToNodeOffset, l = containmentEdges.length; toNodeFieldIndex < l;\n         toNodeFieldIndex += edgeFieldsCount) {\n      const toNodeIndex = containmentEdges.getValue(toNodeFieldIndex);\n      if (toNodeIndex % nodeFieldCount) {\n        throw new Error('Invalid toNodeIndex ' + toNodeIndex);\n      }\n      ++firstRetainerIndex[toNodeIndex / nodeFieldCount];\n    }\n    for (let i = 0, firstUnusedRetainerSlot = 0; i < nodeCount; i++) {\n      const retainersCount = firstRetainerIndex[i];\n      firstRetainerIndex[i] = firstUnusedRetainerSlot;\n      retainingNodes[firstUnusedRetainerSlot] = retainersCount;\n      firstUnusedRetainerSlot += retainersCount;\n    }\n    firstRetainerIndex[nodeCount] = retainingNodes.length;\n\n    let nextNodeFirstEdgeIndex: number = firstEdgeIndexes[0];\n    for (let srcNodeOrdinal = 0; srcNodeOrdinal < nodeCount; ++srcNodeOrdinal) {\n      const firstEdgeIndex = nextNodeFirstEdgeIndex;\n      nextNodeFirstEdgeIndex = firstEdgeIndexes[srcNodeOrdinal + 1];\n      const srcNodeIndex = srcNodeOrdinal * nodeFieldCount;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < nextNodeFirstEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const toNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        if (toNodeIndex % nodeFieldCount) {\n          throw new Error('Invalid toNodeIndex ' + toNodeIndex);\n        }\n        const firstRetainerSlotIndex = firstRetainerIndex[toNodeIndex / nodeFieldCount];\n        const nextUnusedRetainerSlotIndex = firstRetainerSlotIndex + (--retainingNodes[firstRetainerSlotIndex]);\n        retainingNodes[nextUnusedRetainerSlotIndex] = srcNodeIndex;\n        retainingEdges[nextUnusedRetainerSlotIndex] = edgeIndex;\n      }\n    }\n  }\n\n  abstract createNode(_nodeIndex?: number): HeapSnapshotNode;\n  abstract createEdge(_edgeIndex: number): JSHeapSnapshotEdge;\n  abstract createRetainingEdge(_retainerIndex: number): JSHeapSnapshotRetainerEdge;\n\n  private allNodes(): HeapSnapshotNodeIterator {\n    return new HeapSnapshotNodeIterator(this.rootNode());\n  }\n\n  rootNode(): HeapSnapshotNode {\n    return this.createNode(this.rootNodeIndexInternal);\n  }\n\n  get rootNodeIndex(): number {\n    return this.rootNodeIndexInternal;\n  }\n\n  get totalSize(): number {\n    return this.rootNode().retainedSize();\n  }\n\n  private getDominatedIndex(nodeIndex: number): number {\n    if (nodeIndex % this.nodeFieldCount) {\n      throw new Error('Invalid nodeIndex: ' + nodeIndex);\n    }\n    return this.firstDominatedNodeIndex[nodeIndex / this.nodeFieldCount];\n  }\n\n  private createFilter(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      ((arg0: HeapSnapshotNode) => boolean)|undefined {\n    const {minNodeId, maxNodeId, allocationNodeId, filterName} = nodeFilter;\n    let filter;\n    if (typeof allocationNodeId === 'number') {\n      filter = this.createAllocationStackFilter(allocationNodeId);\n      if (!filter) {\n        throw new Error('Unable to create filter');\n      }\n      // @ts-ignore key can be added as a static property\n      filter.key = 'AllocationNodeId: ' + allocationNodeId;\n    } else if (typeof minNodeId === 'number' && typeof maxNodeId === 'number') {\n      filter = this.createNodeIdFilter(minNodeId, maxNodeId);\n      // @ts-ignore key can be added as a static property\n      filter.key = 'NodeIdRange: ' + minNodeId + '..' + maxNodeId;\n    } else if (filterName !== undefined) {\n      filter = this.createNamedFilter(filterName);\n      // @ts-ignore key can be added as a static property\n      filter.key = 'NamedFilter: ' + filterName;\n    }\n    return filter;\n  }\n\n  search(\n      searchConfig: HeapSnapshotModel.HeapSnapshotModel.SearchConfig,\n      nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter): number[] {\n    const query = searchConfig.query;\n\n    function filterString(matchedStringIndexes: Set<number>, string: string, index: number): Set<number> {\n      if (string.indexOf(query) !== -1) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const regexp =\n        searchConfig.isRegex ? new RegExp(query) : Platform.StringUtilities.createPlainTextSearchRegex(query, 'i');\n\n    function filterRegexp(matchedStringIndexes: Set<number>, string: string, index: number): Set<number> {\n      if (regexp.test(string)) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const stringFilter = (searchConfig.isRegex || !searchConfig.caseSensitive) ? filterRegexp : filterString;\n    const stringIndexes = this.strings.reduce(stringFilter, new Set());\n\n    if (!stringIndexes.size) {\n      return [];\n    }\n\n    const filter = this.createFilter(nodeFilter);\n    const nodeIds = [];\n    const nodesLength = this.nodes.length;\n    const nodes = this.nodes;\n    const nodeNameOffset = this.nodeNameOffset;\n    const nodeIdOffset = this.nodeIdOffset;\n    const nodeFieldCount = this.nodeFieldCount;\n    const node = this.rootNode();\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      if (stringIndexes.has(nodes.getValue(nodeIndex + nodeNameOffset))) {\n        nodeIds.push(nodes.getValue(nodeIndex + nodeIdOffset));\n      }\n    }\n    return nodeIds;\n  }\n\n  aggregatesWithFilter(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate} {\n    const filter = this.createFilter(nodeFilter);\n    // @ts-ignore key is added in createFilter\n    const key = filter ? filter.key : 'allObjects';\n    return this.getAggregatesByClassName(false, key, filter);\n  }\n\n  private createNodeIdFilter(minNodeId: number, maxNodeId: number): (arg0: HeapSnapshotNode) => boolean {\n    function nodeIdFilter(node: HeapSnapshotNode): boolean {\n      const id = node.id();\n      return id > minNodeId && id <= maxNodeId;\n    }\n    return nodeIdFilter;\n  }\n\n  private createAllocationStackFilter(bottomUpAllocationNodeId: number):\n      ((arg0: HeapSnapshotNode) => boolean)|undefined {\n    if (!this.#allocationProfile) {\n      throw new Error('No Allocation Profile provided');\n    }\n\n    const traceIds = this.#allocationProfile.traceIds(bottomUpAllocationNodeId);\n    if (!traceIds.length) {\n      return undefined;\n    }\n\n    const set: {[x: number]: boolean} = {};\n    for (let i = 0; i < traceIds.length; i++) {\n      set[traceIds[i]] = true;\n    }\n    function traceIdFilter(node: HeapSnapshotNode): boolean {\n      return Boolean(set[node.traceNodeId()]);\n    }\n    return traceIdFilter;\n  }\n\n  private createNamedFilter(filterName: string): (node: HeapSnapshotNode) => boolean {\n    // Allocate an array with a single bit per node, which can be used by each\n    // specific filter implemented below.\n    const bitmap = new Uint8Array(Math.ceil(this.nodeCount / 8));\n    const getBit = (node: HeapSnapshotNode): boolean => {\n      const ordinal = node.nodeIndex / this.nodeFieldCount;\n      const value = bitmap[ordinal >> 3] & (1 << (ordinal & 7));\n      return value !== 0;\n    };\n    const setBit = (nodeOrdinal: number): void => {\n      bitmap[nodeOrdinal >> 3] |= (1 << (nodeOrdinal & 7));\n    };\n\n    // Traverses the graph in breadth-first order with the given filter, and\n    // sets the bit in `bitmap` for every visited node.\n    const traverse = (filter: (node: HeapSnapshotNode, edge: HeapSnapshotEdge) => boolean): void => {\n      const distances = new Int32Array(this.nodeCount);\n      for (let i = 0; i < this.nodeCount; ++i) {\n        distances[i] = this.#noDistance;\n      }\n      const nodesToVisit = new Uint32Array(this.nodeCount);\n      distances[this.rootNode().ordinal()] = 0;\n      nodesToVisit[0] = this.rootNode().nodeIndex;\n      const nodesToVisitLength = 1;\n      this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n      for (let i = 0; i < this.nodeCount; ++i) {\n        if (distances[i] !== this.#noDistance) {\n          setBit(i);\n        }\n      }\n    };\n\n    const markUnreachableNodes = (): void => {\n      for (let i = 0; i < this.nodeCount; ++i) {\n        if (this.nodeDistances[i] === this.#noDistance) {\n          setBit(i);\n        }\n      }\n    };\n\n    switch (filterName) {\n      case 'objectsRetainedByDetachedDomNodes':\n        // Traverse the graph, avoiding detached nodes.\n        traverse((node: HeapSnapshotNode, edge: HeapSnapshotEdge) => {\n          return this.nodes.getValue(edge.nodeIndex() + this.#nodeDetachednessOffset) !== DOMLinkState.Detached;\n        });\n        markUnreachableNodes();\n        return (node: HeapSnapshotNode) => !getBit(node);\n      case 'objectsRetainedByConsole':\n        // Traverse the graph, avoiding edges that represent globals owned by\n        // the DevTools console.\n        traverse((node: HeapSnapshotNode, edge: HeapSnapshotEdge) => {\n          return !(node.isSynthetic() && edge.hasStringName() && edge.name().endsWith(' / DevTools console'));\n        });\n        markUnreachableNodes();\n        return (node: HeapSnapshotNode) => !getBit(node);\n      case 'duplicatedStrings': {\n        const stringToNodeIndexMap = new Map<string, number>();\n        const node = this.createNode(0);\n        for (let i = 0; i < this.nodeCount; ++i) {\n          node.nodeIndex = i * this.nodeFieldCount;\n          const rawType = node.rawType();\n          if (rawType === this.nodeStringType || rawType === this.nodeConsStringType) {\n            // Check whether the cons string is already \"flattened\", meaning\n            // that one of its two parts is the empty string. If so, we should\n            // skip it. We don't help anyone by reporting a flattened cons\n            // string as a duplicate with its own content, since V8 controls\n            // that behavior internally.\n            if (node.isFlatConsString()) {\n              continue;\n            }\n            const name = node.name();\n            const alreadyVisitedNodeIndex = stringToNodeIndexMap.get(name);\n            if (alreadyVisitedNodeIndex === undefined) {\n              stringToNodeIndexMap.set(name, node.nodeIndex);\n            } else {\n              setBit(alreadyVisitedNodeIndex / this.nodeFieldCount);\n              setBit(node.nodeIndex / this.nodeFieldCount);\n            }\n          }\n        }\n        return getBit;\n      }\n    }\n    throw new Error('Invalid filter name');\n  }\n\n  getAggregatesByClassName(sortedIndexes: boolean, key?: string, filter?: ((arg0: HeapSnapshotNode) => boolean)):\n      {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate} {\n    const aggregates = this.buildAggregates(filter);\n\n    let aggregatesByClassName;\n    if (key && this.#aggregates[key]) {\n      aggregatesByClassName = this.#aggregates[key];\n    } else {\n      this.calculateClassesRetainedSize(aggregates.aggregatesByClassIndex, filter);\n      aggregatesByClassName = aggregates.aggregatesByClassName;\n      if (key) {\n        this.#aggregates[key] = aggregatesByClassName;\n      }\n    }\n\n    if (sortedIndexes && (!key || !this.#aggregatesSortedFlags[key])) {\n      this.sortAggregateIndexes(aggregatesByClassName);\n      if (key) {\n        this.#aggregatesSortedFlags[key] = sortedIndexes;\n      }\n    }\n\n    return aggregatesByClassName as {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate,\n    };\n  }\n\n  allocationTracesTops(): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[] {\n    return this.#allocationProfile.serializeTraceTops();\n  }\n\n  allocationNodeCallers(nodeId: number): HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers {\n    return this.#allocationProfile.serializeCallers(nodeId);\n  }\n\n  allocationStack(nodeIndex: number): HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame[]|null {\n    const node = this.createNode(nodeIndex);\n    const allocationNodeId = node.traceNodeId();\n    if (!allocationNodeId) {\n      return null;\n    }\n    return this.#allocationProfile.serializeAllocationStack(allocationNodeId);\n  }\n\n  aggregatesForDiff(): {[x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff} {\n    if (this.#aggregatesForDiffInternal) {\n      return this.#aggregatesForDiffInternal;\n    }\n\n    const aggregatesByClassName = this.getAggregatesByClassName(true, 'allObjects');\n    this.#aggregatesForDiffInternal = {};\n\n    const node = this.createNode();\n    for (const className in aggregatesByClassName) {\n      const aggregate = aggregatesByClassName[className];\n      const indexes = aggregate.idxs;\n      const ids = new Array(indexes.length);\n      const selfSizes = new Array(indexes.length);\n      for (let i = 0; i < indexes.length; i++) {\n        node.nodeIndex = indexes[i];\n        ids[i] = node.id();\n        selfSizes[i] = node.selfSize();\n      }\n\n      this.#aggregatesForDiffInternal[className] = {indexes: indexes, ids: ids, selfSizes: selfSizes};\n    }\n    return this.#aggregatesForDiffInternal;\n  }\n\n  isUserRoot(_node: HeapSnapshotNode): boolean {\n    return true;\n  }\n\n  calculateShallowSizes(): void {\n  }\n\n  calculateDistances(\n      isForRetainersView: boolean, filter?: ((arg0: HeapSnapshotNode, arg1: HeapSnapshotEdge) => boolean)): void {\n    const nodeCount = this.nodeCount;\n\n    if (isForRetainersView) {\n      const originalFilter = filter;\n      filter = (node: HeapSnapshotNode, edge: HeapSnapshotEdge) => {\n        return !this.#ignoredNodesInRetainersView.has(edge.nodeIndex()) &&\n            (!originalFilter || originalFilter(node, edge));\n      };\n      if (this.#nodeDistancesForRetainersView === undefined) {\n        this.#nodeDistancesForRetainersView = new Int32Array(nodeCount);\n      }\n    }\n\n    const distances = isForRetainersView ? (this.#nodeDistancesForRetainersView as Int32Array) : this.nodeDistances;\n    const noDistance = this.#noDistance;\n    for (let i = 0; i < nodeCount; ++i) {\n      distances[i] = noDistance;\n    }\n\n    const nodesToVisit = new Uint32Array(this.nodeCount);\n    let nodesToVisitLength = 0;\n\n    // BFS for user root objects.\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      const node = iter.edge.node();\n      if (this.isUserRoot(node)) {\n        distances[node.ordinal()] = 1;\n        nodesToVisit[nodesToVisitLength++] = node.nodeIndex;\n      }\n    }\n    this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n\n    // BFS for objects not reached from user roots.\n    distances[this.rootNode().ordinal()] =\n        nodesToVisitLength > 0 ? HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance : 0;\n    nodesToVisit[0] = this.rootNode().nodeIndex;\n    nodesToVisitLength = 1;\n    this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n  }\n\n  private bfs(\n      nodesToVisit: Uint32Array, nodesToVisitLength: number, distances: Int32Array,\n      filter?: ((arg0: HeapSnapshotNode, arg1: HeapSnapshotEdge) => boolean)): void {\n    // Preload fields into local variables for better performance.\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const nodeFieldCount = this.nodeFieldCount;\n    const containmentEdges = this.containmentEdges;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const nodeCount = this.nodeCount;\n    const edgeWeakType = this.edgeWeakType;\n    const noDistance = this.#noDistance;\n\n    let index = 0;\n    const edge = this.createEdge(0);\n    const node = this.createNode(0);\n    while (index < nodesToVisitLength) {\n      const nodeIndex = nodesToVisit[index++];  // shift generates too much garbage.\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = distances[nodeOrdinal] + 1;\n      const firstEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const edgesEnd = firstEdgeIndexes[nodeOrdinal + 1];\n      node.nodeIndex = nodeIndex;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < edgesEnd; edgeIndex += edgeFieldsCount) {\n        const edgeType = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n        if (edgeType === edgeWeakType) {\n          continue;\n        }\n        const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (distances[childNodeOrdinal] !== noDistance) {\n          continue;\n        }\n        edge.edgeIndex = edgeIndex;\n        if (filter && !filter(node, edge)) {\n          continue;\n        }\n        distances[childNodeOrdinal] = distance;\n        nodesToVisit[nodesToVisitLength++] = childNodeIndex;\n      }\n    }\n    if (nodesToVisitLength > nodeCount) {\n      throw new Error(\n          'BFS failed. Nodes to visit (' + nodesToVisitLength + ') is more than nodes count (' + nodeCount + ')');\n    }\n  }\n\n  private buildAggregates(filter?: ((arg0: HeapSnapshotNode) => boolean)):\n      {aggregatesByClassName: {[x: string]: AggregatedInfo}, aggregatesByClassIndex: {[x: number]: AggregatedInfo}} {\n    const aggregates: {[x: number]: AggregatedInfo} = {};\n\n    const aggregatesByClassName: {[x: string]: AggregatedInfo} = {};\n\n    const classIndexes = [];\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const selfSizeOffset = this.nodeSelfSizeOffset;\n    const node = this.rootNode();\n    const nodeDistances = this.nodeDistances;\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      const selfSize = nodes.getValue(nodeIndex + selfSizeOffset);\n      if (!selfSize) {\n        continue;\n      }\n      const classIndex = node.classIndex();\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = nodeDistances[nodeOrdinal];\n      if (!(classIndex in aggregates)) {\n        const nodeType = node.type();\n        const nameMatters = nodeType === 'object' || nodeType === 'native';\n        const value = {\n          count: 1,\n          distance: distance,\n          self: selfSize,\n          maxRet: 0,\n          type: nodeType,\n          name: nameMatters ? node.name() : null,\n          idxs: [nodeIndex],\n        };\n        aggregates[classIndex] = value;\n        classIndexes.push(classIndex);\n        aggregatesByClassName[node.className()] = value;\n      } else {\n        const clss = aggregates[classIndex];\n        if (!clss) {\n          continue;\n        }\n        clss.distance = Math.min(clss.distance, distance);\n        ++clss.count;\n        clss.self += selfSize;\n        clss.idxs.push(nodeIndex);\n      }\n    }\n\n    // Shave off provisionally allocated space.\n    for (let i = 0, l = classIndexes.length; i < l; ++i) {\n      const classIndex = classIndexes[i];\n      const classIndexValues = aggregates[classIndex];\n      if (!classIndexValues) {\n        continue;\n      }\n      classIndexValues.idxs = classIndexValues.idxs.slice();\n    }\n\n    return {aggregatesByClassName: aggregatesByClassName, aggregatesByClassIndex: aggregates};\n  }\n\n  private calculateClassesRetainedSize(\n      aggregates: {[x: number]: AggregatedInfo}, filter?: ((arg0: HeapSnapshotNode) => boolean)): void {\n    const rootNodeIndex = this.rootNodeIndexInternal;\n    const node = this.createNode(rootNodeIndex);\n    const list = [rootNodeIndex];\n    const sizes = [-1];\n    const classes = [];\n\n    const seenClassNameIndexes = new Map<number, boolean>();\n    const nodeFieldCount = this.nodeFieldCount;\n    const dominatedNodes = this.dominatedNodes;\n    const firstDominatedNodeIndex = this.firstDominatedNodeIndex;\n\n    while (list.length) {\n      const nodeIndex = (list.pop() as number);\n      node.nodeIndex = nodeIndex;\n      let classIndex = node.classIndex();\n      const seen = Boolean(seenClassNameIndexes.get(classIndex));\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const dominatedIndexFrom = firstDominatedNodeIndex[nodeOrdinal];\n      const dominatedIndexTo = firstDominatedNodeIndex[nodeOrdinal + 1];\n\n      if (!seen && (!filter || filter(node)) && node.selfSize()) {\n        aggregates[classIndex].maxRet += node.retainedSize();\n        if (dominatedIndexFrom !== dominatedIndexTo) {\n          seenClassNameIndexes.set(classIndex, true);\n          sizes.push(list.length);\n          classes.push(classIndex);\n        }\n      }\n      for (let i = dominatedIndexFrom; i < dominatedIndexTo; i++) {\n        list.push(dominatedNodes[i]);\n      }\n\n      const l = list.length;\n      while (sizes[sizes.length - 1] === l) {\n        sizes.pop();\n        classIndex = (classes.pop() as number);\n        seenClassNameIndexes.set(classIndex, false);\n      }\n    }\n  }\n\n  private sortAggregateIndexes(aggregates: {[x: string]: AggregatedInfo}): void {\n    const nodeA = this.createNode();\n    const nodeB = this.createNode();\n\n    for (const clss in aggregates) {\n      aggregates[clss].idxs.sort((idxA, idxB) => {\n        nodeA.nodeIndex = idxA;\n        nodeB.nodeIndex = idxB;\n        return nodeA.id() < nodeB.id() ? -1 : 1;\n      });\n    }\n  }\n\n  static tryParseWeakMapEdgeName(edgeName: string): {duplicatedPart: string, tableId: string}|undefined {\n    const ephemeronNameRegex =\n        /^\\d+(?<duplicatedPart> \\/ part of key \\(.*? @\\d+\\) -> value \\(.*? @\\d+\\) pair in WeakMap \\(table @(?<tableId>\\d+)\\))$/;\n    const match = edgeName.match(ephemeronNameRegex);\n    return match ? match.groups as {duplicatedPart: string, tableId: string} : undefined;\n  }\n\n  /**\n   * The function checks is the edge should be considered during building\n   * postorder iterator and dominator tree.\n   */\n  private isEssentialEdge(nodeIndex: number, edgeIndex: number): boolean {\n    const edgeType = this.containmentEdges.getValue(edgeIndex + this.edgeTypeOffset);\n\n    // Values in WeakMaps are retained by the key and table together. Removing\n    // either the key or the table would be sufficient to remove the edge from\n    // the other one, so we needn't use both of those edges when computing\n    // dominators. We've found that the edge from the key generally produces\n    // more useful results, so here we skip the edge from the table.\n    if (edgeType === this.edgeInternalType) {\n      const edgeName = this.strings[this.containmentEdges.getValue(edgeIndex + this.edgeNameOffset)];\n      const match = HeapSnapshot.tryParseWeakMapEdgeName(edgeName);\n      if (match) {\n        const nodeId = this.nodes.getValue(nodeIndex + this.nodeIdOffset);\n        return nodeId !== parseInt(match.tableId, 10);\n      }\n    }\n\n    // Shortcuts at the root node have special meaning of marking user global objects.\n    return edgeType !== this.edgeWeakType &&\n        (edgeType !== this.edgeShortcutType || nodeIndex === this.rootNodeIndexInternal);\n  }\n\n  private buildPostOrderIndex(): {postOrderIndex2NodeOrdinal: Uint32Array, nodeOrdinal2PostOrderIndex: Uint32Array} {\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodeCount = this.nodeCount;\n    const rootNodeOrdinal = this.rootNodeIndexInternal / nodeFieldCount;\n\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n\n    const mapAndFlag = this.userObjectsMapAndFlag();\n    const flags = mapAndFlag ? mapAndFlag.map : null;\n    const flag = mapAndFlag ? mapAndFlag.flag : 0;\n\n    const stackNodes = new Uint32Array(nodeCount);\n    const stackCurrentEdge = new Uint32Array(nodeCount);\n    const postOrderIndex2NodeOrdinal = new Uint32Array(nodeCount);\n    const nodeOrdinal2PostOrderIndex = new Uint32Array(nodeCount);\n    const visited = new Uint8Array(nodeCount);\n    let postOrderIndex = 0;\n\n    let stackTop = 0;\n    stackNodes[0] = rootNodeOrdinal;\n    stackCurrentEdge[0] = firstEdgeIndexes[rootNodeOrdinal];\n    visited[rootNodeOrdinal] = 1;\n\n    let iteration = 0;\n    while (true) {\n      ++iteration;\n      while (stackTop >= 0) {\n        const nodeOrdinal = stackNodes[stackTop];\n        const edgeIndex = stackCurrentEdge[stackTop];\n        const edgesEnd = firstEdgeIndexes[nodeOrdinal + 1];\n\n        if (edgeIndex < edgesEnd) {\n          stackCurrentEdge[stackTop] += edgeFieldsCount;\n          if (!this.isEssentialEdge(nodeOrdinal * nodeFieldCount, edgeIndex)) {\n            continue;\n          }\n          const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n          const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n          if (visited[childNodeOrdinal]) {\n            continue;\n          }\n          const nodeFlag = !flags || (flags[nodeOrdinal] & flag);\n          const childNodeFlag = !flags || (flags[childNodeOrdinal] & flag);\n          // We are skipping the edges from non-page-owned nodes to page-owned nodes.\n          // Otherwise the dominators for the objects that also were retained by debugger would be affected.\n          if (nodeOrdinal !== rootNodeOrdinal && childNodeFlag && !nodeFlag) {\n            continue;\n          }\n          ++stackTop;\n          stackNodes[stackTop] = childNodeOrdinal;\n          stackCurrentEdge[stackTop] = firstEdgeIndexes[childNodeOrdinal];\n          visited[childNodeOrdinal] = 1;\n        } else {\n          // Done with all the node children\n          nodeOrdinal2PostOrderIndex[nodeOrdinal] = postOrderIndex;\n          postOrderIndex2NodeOrdinal[postOrderIndex++] = nodeOrdinal;\n          --stackTop;\n        }\n      }\n\n      if (postOrderIndex === nodeCount || iteration > 1) {\n        break;\n      }\n      const errors = new HeapSnapshotProblemReport(`Heap snapshot: ${\n          nodeCount - postOrderIndex} nodes are unreachable from the root. Following nodes have only weak retainers:`);\n      const dumpNode = this.rootNode();\n      // Remove root from the result (last node in the array) and put it at the bottom of the stack so that it is\n      // visited after all orphan nodes and their subgraphs.\n      --postOrderIndex;\n      stackTop = 0;\n      stackNodes[0] = rootNodeOrdinal;\n      stackCurrentEdge[0] = firstEdgeIndexes[rootNodeOrdinal + 1];  // no need to reiterate its edges\n      for (let i = 0; i < nodeCount; ++i) {\n        if (visited[i] || !this.hasOnlyWeakRetainers(i)) {\n          continue;\n        }\n\n        // Add all nodes that have only weak retainers to traverse their subgraphs.\n        stackNodes[++stackTop] = i;\n        stackCurrentEdge[stackTop] = firstEdgeIndexes[i];\n        visited[i] = 1;\n\n        dumpNode.nodeIndex = i * nodeFieldCount;\n        const retainers = [];\n        for (let it = dumpNode.retainers(); it.hasNext(); it.next()) {\n          retainers.push(`${it.item().node().name()}@${it.item().node().id()}.${it.item().name()}`);\n        }\n        errors.addError(`${dumpNode.name()} @${dumpNode.id()}  weak retainers: ${retainers.join(', ')}`);\n      }\n      console.warn(errors.toString());\n    }\n\n    // If we already processed all orphan nodes that have only weak retainers and still have some orphans...\n    if (postOrderIndex !== nodeCount) {\n      const errors = new HeapSnapshotProblemReport(\n          'Still found ' + (nodeCount - postOrderIndex) + ' unreachable nodes in heap snapshot:');\n      const dumpNode = this.rootNode();\n      // Remove root from the result (last node in the array) and put it at the bottom of the stack so that it is\n      // visited after all orphan nodes and their subgraphs.\n      --postOrderIndex;\n      for (let i = 0; i < nodeCount; ++i) {\n        if (visited[i]) {\n          continue;\n        }\n        dumpNode.nodeIndex = i * nodeFieldCount;\n        errors.addError(dumpNode.name() + ' @' + dumpNode.id());\n        // Fix it by giving the node a postorder index anyway.\n        nodeOrdinal2PostOrderIndex[i] = postOrderIndex;\n        postOrderIndex2NodeOrdinal[postOrderIndex++] = i;\n      }\n      nodeOrdinal2PostOrderIndex[rootNodeOrdinal] = postOrderIndex;\n      postOrderIndex2NodeOrdinal[postOrderIndex++] = rootNodeOrdinal;\n      console.warn(errors.toString());\n    }\n\n    return {\n      postOrderIndex2NodeOrdinal: postOrderIndex2NodeOrdinal,\n      nodeOrdinal2PostOrderIndex: nodeOrdinal2PostOrderIndex,\n    };\n  }\n\n  private hasOnlyWeakRetainers(nodeOrdinal: number): boolean {\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeWeakType = this.edgeWeakType;\n    const edgeShortcutType = this.edgeShortcutType;\n    const containmentEdges = this.containmentEdges;\n    const retainingEdges = this.retainingEdges;\n    const beginRetainerIndex = this.firstRetainerIndex[nodeOrdinal];\n    const endRetainerIndex = this.firstRetainerIndex[nodeOrdinal + 1];\n    for (let retainerIndex = beginRetainerIndex; retainerIndex < endRetainerIndex; ++retainerIndex) {\n      const retainerEdgeIndex = retainingEdges[retainerIndex];\n      const retainerEdgeType = containmentEdges.getValue(retainerEdgeIndex + edgeTypeOffset);\n      if (retainerEdgeType !== edgeWeakType && retainerEdgeType !== edgeShortcutType) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // The algorithm is based on the article:\n  // K. Cooper, T. Harvey and K. Kennedy \"A Simple, Fast Dominance Algorithm\"\n  // Softw. Pract. Exper. 4 (2001), pp. 1-10.\n  private buildDominatorTree(postOrderIndex2NodeOrdinal: Uint32Array, nodeOrdinal2PostOrderIndex: Uint32Array):\n      Uint32Array {\n    const nodeFieldCount = this.nodeFieldCount;\n    const firstRetainerIndex = this.firstRetainerIndex;\n    const retainingNodes = this.retainingNodes;\n    const retainingEdges = this.retainingEdges;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n    const rootNodeIndex = this.rootNodeIndexInternal;\n\n    const mapAndFlag = this.userObjectsMapAndFlag();\n    const flags = mapAndFlag ? mapAndFlag.map : null;\n    const flag = mapAndFlag ? mapAndFlag.flag : 0;\n\n    const nodesCount = postOrderIndex2NodeOrdinal.length;\n    const rootPostOrderedIndex = nodesCount - 1;\n    const noEntry = nodesCount;\n    const dominators = new Uint32Array(nodesCount);\n    for (let i = 0; i < rootPostOrderedIndex; ++i) {\n      dominators[i] = noEntry;\n    }\n    dominators[rootPostOrderedIndex] = rootPostOrderedIndex;\n\n    // The affected array is used to mark entries which dominators\n    // have to be recalculated because of changes in their retainers.\n    const affected = new Uint8Array(nodesCount);\n    let nodeOrdinal;\n\n    {  // Mark the root direct children as affected.\n      nodeOrdinal = this.rootNodeIndexInternal / nodeFieldCount;\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = firstEdgeIndexes[nodeOrdinal]; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        if (!this.isEssentialEdge(this.rootNodeIndexInternal, edgeIndex)) {\n          continue;\n        }\n        const childNodeOrdinal = containmentEdges.getValue(edgeIndex + edgeToNodeOffset) / nodeFieldCount;\n        affected[nodeOrdinal2PostOrderIndex[childNodeOrdinal]] = 1;\n      }\n    }\n\n    let changed = true;\n    while (changed) {\n      changed = false;\n      for (let postOrderIndex = rootPostOrderedIndex - 1; postOrderIndex >= 0; --postOrderIndex) {\n        if (affected[postOrderIndex] === 0) {\n          continue;\n        }\n        affected[postOrderIndex] = 0;\n        // If dominator of the entry has already been set to root,\n        // then it can't propagate any further.\n        if (dominators[postOrderIndex] === rootPostOrderedIndex) {\n          continue;\n        }\n        nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n        const nodeFlag = !flags || (flags[nodeOrdinal] & flag);\n        let newDominatorIndex: number = noEntry;\n        const beginRetainerIndex = firstRetainerIndex[nodeOrdinal];\n        const endRetainerIndex = firstRetainerIndex[nodeOrdinal + 1];\n        let orphanNode = true;\n        for (let retainerIndex = beginRetainerIndex; retainerIndex < endRetainerIndex; ++retainerIndex) {\n          const retainerEdgeIndex = retainingEdges[retainerIndex];\n          const retainerNodeIndex = retainingNodes[retainerIndex];\n          if (!this.isEssentialEdge(retainerNodeIndex, retainerEdgeIndex)) {\n            continue;\n          }\n          orphanNode = false;\n          const retainerNodeOrdinal = retainerNodeIndex / nodeFieldCount;\n          const retainerNodeFlag = !flags || (flags[retainerNodeOrdinal] & flag);\n          // We are skipping the edges from non-page-owned nodes to page-owned nodes.\n          // Otherwise the dominators for the objects that also were retained by debugger would be affected.\n          if (retainerNodeIndex !== rootNodeIndex && nodeFlag && !retainerNodeFlag) {\n            continue;\n          }\n          let retainerPostOrderIndex: number = nodeOrdinal2PostOrderIndex[retainerNodeOrdinal];\n          if (dominators[retainerPostOrderIndex] !== noEntry) {\n            if (newDominatorIndex === noEntry) {\n              newDominatorIndex = retainerPostOrderIndex;\n            } else {\n              while (retainerPostOrderIndex !== newDominatorIndex) {\n                while (retainerPostOrderIndex < newDominatorIndex) {\n                  retainerPostOrderIndex = dominators[retainerPostOrderIndex];\n                }\n                while (newDominatorIndex < retainerPostOrderIndex) {\n                  newDominatorIndex = dominators[newDominatorIndex];\n                }\n              }\n            }\n            // If item has already reached the root, it doesn't make sense\n            // to check other retainers.\n            if (newDominatorIndex === rootPostOrderedIndex) {\n              break;\n            }\n          }\n        }\n        // Make root dominator of orphans.\n        if (orphanNode) {\n          newDominatorIndex = rootPostOrderedIndex;\n        }\n        if (newDominatorIndex !== noEntry && dominators[postOrderIndex] !== newDominatorIndex) {\n          dominators[postOrderIndex] = newDominatorIndex;\n          changed = true;\n          nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n          const beginEdgeToNodeFieldIndex = firstEdgeIndexes[nodeOrdinal] + edgeToNodeOffset;\n          const endEdgeToNodeFieldIndex = firstEdgeIndexes[nodeOrdinal + 1];\n          for (let toNodeFieldIndex = beginEdgeToNodeFieldIndex; toNodeFieldIndex < endEdgeToNodeFieldIndex;\n               toNodeFieldIndex += edgeFieldsCount) {\n            const childNodeOrdinal = containmentEdges.getValue(toNodeFieldIndex) / nodeFieldCount;\n            affected[nodeOrdinal2PostOrderIndex[childNodeOrdinal]] = 1;\n          }\n        }\n      }\n    }\n\n    const dominatorsTree = new Uint32Array(nodesCount);\n    for (let postOrderIndex = 0, l = dominators.length; postOrderIndex < l; ++postOrderIndex) {\n      nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n      dominatorsTree[nodeOrdinal] = postOrderIndex2NodeOrdinal[dominators[postOrderIndex]];\n    }\n    return dominatorsTree;\n  }\n\n  private calculateRetainedSizes(postOrderIndex2NodeOrdinal: Uint32Array): void {\n    const nodeCount = this.nodeCount;\n    const nodes = this.nodes;\n    const nodeSelfSizeOffset = this.nodeSelfSizeOffset;\n    const nodeFieldCount = this.nodeFieldCount;\n    const dominatorsTree = this.dominatorsTree;\n    const retainedSizes = this.retainedSizes;\n\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      retainedSizes[nodeOrdinal] = nodes.getValue(nodeOrdinal * nodeFieldCount + nodeSelfSizeOffset);\n    }\n\n    // Propagate retained sizes for each node excluding root.\n    for (let postOrderIndex = 0; postOrderIndex < nodeCount - 1; ++postOrderIndex) {\n      const nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      retainedSizes[dominatorOrdinal] += retainedSizes[nodeOrdinal];\n    }\n  }\n\n  private buildDominatedNodes(): void {\n    // Builds up two arrays:\n    //  - \"dominatedNodes\" is a continuous array, where each node owns an\n    //    interval (can be empty) with corresponding dominated nodes.\n    //  - \"indexArray\" is an array of indexes in the \"dominatedNodes\"\n    //    with the same positions as in the _nodeIndex.\n    const indexArray = this.firstDominatedNodeIndex;\n    // All nodes except the root have dominators.\n    const dominatedNodes = this.dominatedNodes;\n\n    // Count the number of dominated nodes for each node. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n    const nodeFieldCount = this.nodeFieldCount;\n    const dominatorsTree = this.dominatorsTree;\n\n    let fromNodeOrdinal = 0;\n    let toNodeOrdinal: number = this.nodeCount;\n    const rootNodeOrdinal = this.rootNodeIndexInternal / nodeFieldCount;\n    if (rootNodeOrdinal === fromNodeOrdinal) {\n      fromNodeOrdinal = 1;\n    } else if (rootNodeOrdinal === toNodeOrdinal - 1) {\n      toNodeOrdinal = toNodeOrdinal - 1;\n    } else {\n      throw new Error('Root node is expected to be either first or last');\n    }\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      ++indexArray[dominatorsTree[nodeOrdinal]];\n    }\n    // Put in the first slot of each dominatedNodes slice the count of entries\n    // that will be filled.\n    let firstDominatedNodeIndex = 0;\n    for (let i = 0, l = this.nodeCount; i < l; ++i) {\n      const dominatedCount = dominatedNodes[firstDominatedNodeIndex] = indexArray[i];\n      indexArray[i] = firstDominatedNodeIndex;\n      firstDominatedNodeIndex += dominatedCount;\n    }\n    indexArray[this.nodeCount] = dominatedNodes.length;\n    // Fill up the dominatedNodes array with indexes of dominated nodes. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      let dominatedRefIndex = indexArray[dominatorOrdinal];\n      dominatedRefIndex += (--dominatedNodes[dominatedRefIndex]);\n      dominatedNodes[dominatedRefIndex] = nodeOrdinal * nodeFieldCount;\n    }\n  }\n\n  /**\n   * Iterates children of a node.\n   */\n  private iterateFilteredChildren(\n      nodeOrdinal: number, edgeFilterCallback: (arg0: number) => boolean, childCallback: (arg0: number) => void): void {\n    const beginEdgeIndex = this.firstEdgeIndexes[nodeOrdinal];\n    const endEdgeIndex = this.firstEdgeIndexes[nodeOrdinal + 1];\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += this.edgeFieldsCount) {\n      const childNodeIndex = this.containmentEdges.getValue(edgeIndex + this.edgeToNodeOffset);\n      const childNodeOrdinal = childNodeIndex / this.nodeFieldCount;\n      const type = this.containmentEdges.getValue(edgeIndex + this.edgeTypeOffset);\n      if (!edgeFilterCallback(type)) {\n        continue;\n      }\n      childCallback(childNodeOrdinal);\n    }\n  }\n\n  /**\n   * Adds a string to the snapshot.\n   */\n  private addString(string: string): number {\n    this.strings.push(string);\n    return this.strings.length - 1;\n  }\n\n  /**\n   * The phase propagates whether a node is attached or detached through the\n   * graph and adjusts the low-level representation of nodes.\n   *\n   * State propagation:\n   * 1. Any object reachable from an attached object is itself attached.\n   * 2. Any object reachable from a detached object that is not already\n   *    attached is considered detached.\n   *\n   * Representation:\n   * - Name of any detached node is changed from \"<Name>\"\" to\n   *   \"Detached <Name>\".\n   */\n  private propagateDOMState(): void {\n    if (this.#nodeDetachednessOffset === -1) {\n      return;\n    }\n\n    console.time('propagateDOMState');\n\n    const visited = new Uint8Array(this.nodeCount);\n    const attached: number[] = [];\n    const detached: number[] = [];\n\n    const stringIndexCache = new Map<number, number>();\n\n    /**\n     * Adds a 'Detached ' prefix to the name of a node.\n     */\n    const addDetachedPrefixToNodeName = function(snapshot: HeapSnapshot, nodeIndex: number): void {\n      const oldStringIndex = snapshot.nodes.getValue(nodeIndex + snapshot.nodeNameOffset);\n      let newStringIndex = stringIndexCache.get(oldStringIndex);\n      if (newStringIndex === undefined) {\n        newStringIndex = snapshot.addString('Detached ' + snapshot.strings[oldStringIndex]);\n        stringIndexCache.set(oldStringIndex, newStringIndex);\n      }\n      snapshot.nodes.setValue(nodeIndex + snapshot.nodeNameOffset, newStringIndex);\n    };\n\n    /**\n     * Processes a node represented by nodeOrdinal:\n     * - Changes its name based on newState.\n     * - Puts it onto working sets for attached or detached nodes.\n     */\n    const processNode = function(snapshot: HeapSnapshot, nodeOrdinal: number, newState: number): void {\n      if (visited[nodeOrdinal]) {\n        return;\n      }\n\n      const nodeIndex = nodeOrdinal * snapshot.nodeFieldCount;\n\n      // Early bailout: Do not propagate the state (and name change) through JavaScript. Every\n      // entry point into embedder code is a node that knows its own state. All embedder nodes\n      // have their node type set to native.\n      if (snapshot.nodes.getValue(nodeIndex + snapshot.nodeTypeOffset) !== snapshot.nodeNativeType) {\n        visited[nodeOrdinal] = 1;\n        return;\n      }\n\n      snapshot.nodes.setValue(nodeIndex + snapshot.#nodeDetachednessOffset, newState);\n\n      if (newState === DOMLinkState.Attached) {\n        attached.push(nodeOrdinal);\n      } else if (newState === DOMLinkState.Detached) {\n        // Detached state: Rewire node name.\n        addDetachedPrefixToNodeName(snapshot, nodeIndex);\n        detached.push(nodeOrdinal);\n      }\n\n      visited[nodeOrdinal] = 1;\n    };\n\n    const propagateState = function(snapshot: HeapSnapshot, parentNodeOrdinal: number, newState: number): void {\n      snapshot.iterateFilteredChildren(\n          parentNodeOrdinal,\n          edgeType => ![snapshot.edgeHiddenType, snapshot.edgeInvisibleType, snapshot.edgeWeakType].includes(edgeType),\n          nodeOrdinal => processNode(snapshot, nodeOrdinal, newState));\n    };\n\n    // 1. We re-use the deserialized field to store the propagated state. While\n    //    the state for known nodes is already set, they still need to go\n    //    through processing to have their name adjusted and them enqueued in\n    //    the respective queues.\n    for (let nodeOrdinal = 0; nodeOrdinal < this.nodeCount; ++nodeOrdinal) {\n      const state = this.nodes.getValue(nodeOrdinal * this.nodeFieldCount + this.#nodeDetachednessOffset);\n      // Bail out for objects that have no known state. For all other objects set that state.\n      if (state === DOMLinkState.Unknown) {\n        continue;\n      }\n      processNode(this, nodeOrdinal, state);\n    }\n    // 2. If the parent is attached, then the child is also attached.\n    while (attached.length !== 0) {\n      const nodeOrdinal = (attached.pop() as number);\n      propagateState(this, nodeOrdinal, DOMLinkState.Attached);\n    }\n    // 3. If the parent is not attached, then the child inherits the parent's state.\n    while (detached.length !== 0) {\n      const nodeOrdinal = (detached.pop() as number);\n      const nodeState = this.nodes.getValue(nodeOrdinal * this.nodeFieldCount + this.#nodeDetachednessOffset);\n      // Ignore if the node has been found through propagating forward attached state.\n      if (nodeState === DOMLinkState.Attached) {\n        continue;\n      }\n      propagateState(this, nodeOrdinal, DOMLinkState.Detached);\n    }\n\n    console.timeEnd('propagateDOMState');\n  }\n\n  private buildSamples(): void {\n    const samples = this.#rawSamples;\n    if (!samples || !samples.length) {\n      return;\n    }\n    const sampleCount = samples.length / 2;\n    const sizeForRange = new Array(sampleCount);\n    const timestamps = new Array(sampleCount);\n    const lastAssignedIds = new Array(sampleCount);\n\n    const timestampOffset = this.#metaNode.sample_fields.indexOf('timestamp_us');\n    const lastAssignedIdOffset = this.#metaNode.sample_fields.indexOf('last_assigned_id');\n    for (let i = 0; i < sampleCount; i++) {\n      sizeForRange[i] = 0;\n      timestamps[i] = (samples[2 * i + timestampOffset]) / 1000;\n      lastAssignedIds[i] = samples[2 * i + lastAssignedIdOffset];\n    }\n\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n\n      const nodeId = node.id();\n      // JS objects have odd ids, skip native objects.\n      if (nodeId % 2 === 0) {\n        continue;\n      }\n      const rangeIndex =\n          Platform.ArrayUtilities.lowerBound(lastAssignedIds, nodeId, Platform.ArrayUtilities.DEFAULT_COMPARATOR);\n      if (rangeIndex === sampleCount) {\n        // TODO: make heap profiler not allocate while taking snapshot\n        continue;\n      }\n      sizeForRange[rangeIndex] += node.selfSize();\n    }\n    this.#samples = new HeapSnapshotModel.HeapSnapshotModel.Samples(timestamps, lastAssignedIds, sizeForRange);\n  }\n\n  private buildLocationMap(): void {\n    const map = new Map<number, HeapSnapshotModel.HeapSnapshotModel.Location>();\n    const locations = this.#locations;\n\n    for (let i = 0; i < locations.length; i += this.#locationFieldCount) {\n      const nodeIndex = locations[i + this.#locationIndexOffset];\n      const scriptId = locations[i + this.#locationScriptIdOffset];\n      const line = locations[i + this.#locationLineOffset];\n      const col = locations[i + this.#locationColumnOffset];\n      map.set(nodeIndex, new HeapSnapshotModel.HeapSnapshotModel.Location(scriptId, line, col));\n    }\n\n    this.#locationMap = map;\n  }\n\n  getLocation(nodeIndex: number): HeapSnapshotModel.HeapSnapshotModel.Location|null {\n    return this.#locationMap.get(nodeIndex) || null;\n  }\n\n  getSamples(): HeapSnapshotModel.HeapSnapshotModel.Samples|null {\n    return this.#samples;\n  }\n\n  calculateFlags(): void {\n    throw new Error('Not implemented');\n  }\n\n  calculateStatistics(): void {\n    throw new Error('Not implemented');\n  }\n\n  userObjectsMapAndFlag(): {map: Uint32Array, flag: number}|null {\n    throw new Error('Not implemented');\n  }\n\n  calculateSnapshotDiff(\n      baseSnapshotId: string,\n      baseSnapshotAggregates: {[x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff}):\n      {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff} {\n    let snapshotDiff: {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff}|{\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff,\n    } = this.#snapshotDiffs[baseSnapshotId];\n    if (snapshotDiff) {\n      return snapshotDiff;\n    }\n    snapshotDiff = ({} as {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff,\n    });\n\n    const aggregates = this.getAggregatesByClassName(true, 'allObjects');\n    for (const className in baseSnapshotAggregates) {\n      const baseAggregate = baseSnapshotAggregates[className];\n      const diff = this.calculateDiffForClass(baseAggregate, aggregates[className]);\n      if (diff) {\n        snapshotDiff[className] = diff;\n      }\n    }\n    const emptyBaseAggregate = new HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff();\n    for (const className in aggregates) {\n      if (className in baseSnapshotAggregates) {\n        continue;\n      }\n      const classDiff = this.calculateDiffForClass(emptyBaseAggregate, aggregates[className]);\n      if (classDiff) {\n        snapshotDiff[className] = classDiff;\n      }\n    }\n\n    this.#snapshotDiffs[baseSnapshotId] = snapshotDiff;\n    return snapshotDiff;\n  }\n\n  private calculateDiffForClass(\n      baseAggregate: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff,\n      aggregate: HeapSnapshotModel.HeapSnapshotModel.Aggregate): HeapSnapshotModel.HeapSnapshotModel.Diff|null {\n    const baseIds = baseAggregate.ids;\n    const baseIndexes = baseAggregate.indexes;\n    const baseSelfSizes = baseAggregate.selfSizes;\n\n    const indexes = aggregate ? aggregate.idxs : [];\n\n    let i = 0;\n    let j = 0;\n    const l = baseIds.length;\n    const m = indexes.length;\n    const diff = new HeapSnapshotModel.HeapSnapshotModel.Diff();\n\n    const nodeB = this.createNode(indexes[j]);\n    while (i < l && j < m) {\n      const nodeAId = baseIds[i];\n      if (nodeAId < nodeB.id()) {\n        diff.deletedIndexes.push(baseIndexes[i]);\n        diff.removedCount++;\n        diff.removedSize += baseSelfSizes[i];\n        ++i;\n      } else if (\n          nodeAId >\n          nodeB.id()) {  // Native nodes(e.g. dom groups) may have ids less than max JS object id in the base snapshot\n        diff.addedIndexes.push(indexes[j]);\n        diff.addedCount++;\n        diff.addedSize += nodeB.selfSize();\n        nodeB.nodeIndex = indexes[++j];\n      } else {  // nodeAId === nodeB.id()\n        ++i;\n        nodeB.nodeIndex = indexes[++j];\n      }\n    }\n    while (i < l) {\n      diff.deletedIndexes.push(baseIndexes[i]);\n      diff.removedCount++;\n      diff.removedSize += baseSelfSizes[i];\n      ++i;\n    }\n    while (j < m) {\n      diff.addedIndexes.push(indexes[j]);\n      diff.addedCount++;\n      diff.addedSize += nodeB.selfSize();\n      nodeB.nodeIndex = indexes[++j];\n    }\n    diff.countDelta = diff.addedCount - diff.removedCount;\n    diff.sizeDelta = diff.addedSize - diff.removedSize;\n    if (!diff.addedCount && !diff.removedCount) {\n      return null;\n    }\n    return diff;\n  }\n\n  private nodeForSnapshotObjectId(snapshotObjectId: number): HeapSnapshotNode|null {\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      if (it.node.id() === snapshotObjectId) {\n        return it.node;\n      }\n    }\n    return null;\n  }\n\n  nodeClassName(snapshotObjectId: number): string|null {\n    const node = this.nodeForSnapshotObjectId(snapshotObjectId);\n    if (node) {\n      return node.className();\n    }\n    return null;\n  }\n\n  idsOfObjectsWithName(name: string): number[] {\n    const ids = [];\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      if (it.item().name() === name) {\n        ids.push(it.item().id());\n      }\n    }\n    return ids;\n  }\n\n  createEdgesProvider(nodeIndex: number): HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const filter = this.containmentEdgesFilter();\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  createEdgesProviderForTest(nodeIndex: number, filter: ((arg0: HeapSnapshotEdge) => boolean)|null):\n      HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  retainingEdgesFilter(): ((arg0: HeapSnapshotEdge) => boolean)|null {\n    return null;\n  }\n\n  containmentEdgesFilter(): ((arg0: HeapSnapshotEdge) => boolean)|null {\n    return null;\n  }\n\n  createRetainingEdgesProvider(nodeIndex: number): HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const filter = this.retainingEdgesFilter();\n    const indexProvider = new HeapSnapshotRetainerEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.retainers(), indexProvider);\n  }\n\n  createAddedNodesProvider(baseSnapshotId: string, className: string): HeapSnapshotNodesProvider {\n    const snapshotDiff = this.#snapshotDiffs[baseSnapshotId];\n    const diffForClass = snapshotDiff[className];\n    return new HeapSnapshotNodesProvider(this, diffForClass.addedIndexes);\n  }\n\n  createDeletedNodesProvider(nodeIndexes: number[]): HeapSnapshotNodesProvider {\n    return new HeapSnapshotNodesProvider(this, nodeIndexes);\n  }\n\n  createNodesProviderForClass(className: string, nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      HeapSnapshotNodesProvider {\n    return new HeapSnapshotNodesProvider(this, this.aggregatesWithFilter(nodeFilter)[className].idxs);\n  }\n\n  private maxJsNodeId(): number {\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    let id = 0;\n    for (let nodeIndex = this.nodeIdOffset; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nextId = nodes.getValue(nodeIndex);\n      // JS objects have odd ids, skip native objects.\n      if (nextId % 2 === 0) {\n        continue;\n      }\n      if (id < nextId) {\n        id = nextId;\n      }\n    }\n    return id;\n  }\n\n  updateStaticData(): HeapSnapshotModel.HeapSnapshotModel.StaticData {\n    return new HeapSnapshotModel.HeapSnapshotModel.StaticData(\n        this.nodeCount, this.rootNodeIndexInternal, this.totalSize, this.maxJsNodeId());\n  }\n\n  ignoreNodeInRetainersView(nodeIndex: number): void {\n    this.#ignoredNodesInRetainersView.add(nodeIndex);\n    this.calculateDistances(/* isForRetainersView=*/ true);\n    this.#updateIgnoredEdgesInRetainersView();\n  }\n\n  unignoreNodeInRetainersView(nodeIndex: number): void {\n    this.#ignoredNodesInRetainersView.delete(nodeIndex);\n    if (this.#ignoredNodesInRetainersView.size === 0) {\n      this.#nodeDistancesForRetainersView = undefined;\n    } else {\n      this.calculateDistances(/* isForRetainersView=*/ true);\n    }\n    this.#updateIgnoredEdgesInRetainersView();\n  }\n\n  unignoreAllNodesInRetainersView(): void {\n    this.#ignoredNodesInRetainersView.clear();\n    this.#nodeDistancesForRetainersView = undefined;\n    this.#updateIgnoredEdgesInRetainersView();\n  }\n\n  #updateIgnoredEdgesInRetainersView(): void {\n    const distances = this.#nodeDistancesForRetainersView;\n    this.#ignoredEdgesInRetainersView.clear();\n    if (distances === undefined) {\n      return;\n    }\n\n    // To retain a value in a WeakMap, both the WeakMap and the corresponding\n    // key must stay alive. If one of those two retainers is unreachable due to\n    // the user ignoring some nodes, then the other retainer edge should also be\n    // shown as unreachable, since it would be insufficient on its own to retain\n    // the value.\n    const unreachableWeakMapEdges = new Platform.MapUtilities.Multimap<number, string>();\n    const noDistance = this.#noDistance;\n    const {nodeCount, nodeFieldCount} = this;\n    const node = this.createNode(0);\n\n    // Populate unreachableWeakMapEdges.\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      if (distances[nodeOrdinal] !== noDistance) {\n        continue;\n      }\n      node.nodeIndex = nodeOrdinal * nodeFieldCount;\n      for (let iter = node.edges(); iter.hasNext(); iter.next()) {\n        const edge = iter.edge;\n        if (!edge.isInternal()) {\n          continue;\n        }\n        const edgeName = edge.name();\n        const match = HeapSnapshot.tryParseWeakMapEdgeName(edgeName);\n        if (match) {\n          unreachableWeakMapEdges.set(edge.nodeIndex(), match.duplicatedPart);\n        }\n      }\n    }\n\n    // Iterate the retaining edges for the target nodes found in the previous\n    // step and mark any relevant WeakMap edges as ignored.\n    for (const targetNodeIndex of unreachableWeakMapEdges.keys()) {\n      node.nodeIndex = targetNodeIndex;\n      for (let it = node.retainers(); it.hasNext(); it.next()) {\n        const reverseEdge = it.item();\n        if (!reverseEdge.isInternal()) {\n          continue;\n        }\n        const match = HeapSnapshot.tryParseWeakMapEdgeName(reverseEdge.name());\n        if (match && unreachableWeakMapEdges.hasValue(targetNodeIndex, match.duplicatedPart)) {\n          const forwardEdgeIndex = this.retainingEdges[reverseEdge.itemIndex()];\n          this.#ignoredEdgesInRetainersView.add(forwardEdgeIndex);\n        }\n      }\n    }\n  }\n\n  areNodesIgnoredInRetainersView(): boolean {\n    return this.#ignoredNodesInRetainersView.size > 0;\n  }\n\n  getDistanceForRetainersView(nodeIndex: number): number {\n    const nodeOrdinal = nodeIndex / this.nodeFieldCount;\n    const distances = this.#nodeDistancesForRetainersView ?? this.nodeDistances;\n    const distance = distances[nodeOrdinal];\n    if (distance === this.#noDistance) {\n      // An unreachable node should be sorted to the end, not the beginning.\n      // To give such nodes a reasonable sorting order, we add a very large\n      // number to the original distance computed without ignoring any nodes.\n      return Math.max(0, this.nodeDistances[nodeOrdinal]) + HeapSnapshotModel.HeapSnapshotModel.baseUnreachableDistance;\n    }\n    return distance;\n  }\n\n  isNodeIgnoredInRetainersView(nodeIndex: number): boolean {\n    return this.#ignoredNodesInRetainersView.has(nodeIndex);\n  }\n\n  isEdgeIgnoredInRetainersView(edgeIndex: number): boolean {\n    return this.#ignoredEdgesInRetainersView.has(edgeIndex);\n  }\n}\n\nclass HeapSnapshotMetainfo {\n  location_fields: string[] = [];              // eslint-disable-line @typescript-eslint/naming-convention\n  node_fields: string[] = [];                  // eslint-disable-line @typescript-eslint/naming-convention\n  node_types: string[][] = [];                 // eslint-disable-line @typescript-eslint/naming-convention\n  edge_fields: string[] = [];                  // eslint-disable-line @typescript-eslint/naming-convention\n  edge_types: string[][] = [];                 // eslint-disable-line @typescript-eslint/naming-convention\n  trace_function_info_fields: string[] = [];   // eslint-disable-line @typescript-eslint/naming-convention\n  trace_node_fields: string[] = [];            // eslint-disable-line @typescript-eslint/naming-convention\n  sample_fields: string[] = [];                // eslint-disable-line @typescript-eslint/naming-convention\n  type_strings: {[key: string]: string} = {};  // eslint-disable-line @typescript-eslint/naming-convention\n}\n\nexport class HeapSnapshotHeader {\n  title: string;\n  meta: HeapSnapshotMetainfo;\n  node_count: number;            // eslint-disable-line @typescript-eslint/naming-convention\n  edge_count: number;            // eslint-disable-line @typescript-eslint/naming-convention\n  trace_function_count: number;  // eslint-disable-line @typescript-eslint/naming-convention\n  root_index: number;            // eslint-disable-line @typescript-eslint/naming-convention\n  constructor() {\n    // New format.\n    this.title = '';\n    this.meta = new HeapSnapshotMetainfo();\n    this.node_count = 0;\n    this.edge_count = 0;\n    this.trace_function_count = 0;\n    this.root_index = 0;\n  }\n}\n\nexport abstract class HeapSnapshotItemProvider {\n  protected readonly iterator: HeapSnapshotItemIterator;\n  readonly #indexProvider: HeapSnapshotItemIndexProvider;\n  readonly #isEmptyInternal: boolean;\n  protected iterationOrder: number[]|null;\n  protected currentComparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig|null;\n  #sortedPrefixLength: number;\n  #sortedSuffixLength: number;\n  constructor(iterator: HeapSnapshotItemIterator, indexProvider: HeapSnapshotItemIndexProvider) {\n    this.iterator = iterator;\n    this.#indexProvider = indexProvider;\n    this.#isEmptyInternal = !iterator.hasNext();\n    this.iterationOrder = null;\n    this.currentComparator = null;\n    this.#sortedPrefixLength = 0;\n    this.#sortedSuffixLength = 0;\n  }\n\n  protected createIterationOrder(): void {\n    if (this.iterationOrder) {\n      return;\n    }\n    this.iterationOrder = [];\n    for (let iterator = this.iterator; iterator.hasNext(); iterator.next()) {\n      this.iterationOrder.push(iterator.item().itemIndex());\n    }\n  }\n\n  isEmpty(): boolean {\n    return this.#isEmptyInternal;\n  }\n\n  serializeItemsRange(begin: number, end: number): HeapSnapshotModel.HeapSnapshotModel.ItemsRange {\n    this.createIterationOrder();\n    if (begin > end) {\n      throw new Error('Start position > end position: ' + begin + ' > ' + end);\n    }\n\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order undefined');\n    }\n\n    if (end > this.iterationOrder.length) {\n      end = this.iterationOrder.length;\n    }\n    if (this.#sortedPrefixLength < end && begin < this.iterationOrder.length - this.#sortedSuffixLength &&\n        this.currentComparator) {\n      const currentComparator = this.currentComparator;\n      this.sort(\n          currentComparator, this.#sortedPrefixLength, this.iterationOrder.length - 1 - this.#sortedSuffixLength, begin,\n          end - 1);\n      if (begin <= this.#sortedPrefixLength) {\n        this.#sortedPrefixLength = end;\n      }\n      if (end >= this.iterationOrder.length - this.#sortedSuffixLength) {\n        this.#sortedSuffixLength = this.iterationOrder.length - begin;\n      }\n    }\n    let position = begin;\n    const count = end - begin;\n    const result = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      const itemIndex = this.iterationOrder[position++];\n      const item = this.#indexProvider.itemForIndex(itemIndex);\n      result[i] = item.serialize();\n    }\n    return new HeapSnapshotModel.HeapSnapshotModel.ItemsRange(begin, end, this.iterationOrder.length, result);\n  }\n\n  sortAndRewind(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig): void {\n    this.currentComparator = comparator;\n    this.#sortedPrefixLength = 0;\n    this.#sortedSuffixLength = 0;\n  }\n\n  abstract sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void;\n}\n\nexport class HeapSnapshotEdgesProvider extends HeapSnapshotItemProvider {\n  snapshot: HeapSnapshot;\n  constructor(\n      snapshot: HeapSnapshot, filter: ((arg0: HeapSnapshotEdge) => boolean)|null,\n      edgesIter: HeapSnapshotEdgeIterator|HeapSnapshotRetainerEdgeIterator,\n      indexProvider: HeapSnapshotItemIndexProvider) {\n    const iter = filter ? new HeapSnapshotFilteredIterator(edgesIter, (filter as (arg0: HeapSnapshotItem) => boolean)) :\n                          edgesIter;\n    super(iter, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void {\n    const fieldName1 = comparator.fieldName1;\n    const fieldName2 = comparator.fieldName2;\n    const ascending1 = comparator.ascending1;\n    const ascending2 = comparator.ascending2;\n\n    const edgeA = (this.iterator.item() as HeapSnapshotEdge | HeapSnapshotRetainerEdge).clone();\n    const edgeB = edgeA.clone();\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n\n    function compareEdgeField(fieldName: string, ascending: boolean, indexA: number, indexB: number): number {\n      edgeA.edgeIndex = indexA;\n      edgeB.edgeIndex = indexB;\n      let result: number = 0;\n      if (fieldName === '!edgeName') {\n        if (edgeB.name() === '__proto__') {\n          return -1;\n        }\n        if (edgeA.name() === '__proto__') {\n          return 1;\n        }\n        result = edgeA.hasStringName() === edgeB.hasStringName() ?\n            (edgeA.name() < edgeB.name() ? -1 : (edgeA.name() > edgeB.name() ? 1 : 0)) :\n            (edgeA.hasStringName() ? -1 : 1);\n      } else {\n        result = edgeA.getValueForSorting(fieldName) - edgeB.getValueForSorting(fieldName);\n      }\n      return ascending ? result : -result;\n    }\n\n    function compareNodeField(fieldName: string, ascending: boolean, indexA: number, indexB: number): number {\n      edgeA.edgeIndex = indexA;\n      nodeA.nodeIndex = edgeA.nodeIndex();\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const valueA = (nodeA as any)[fieldName]();\n\n      edgeB.edgeIndex = indexB;\n      nodeB.nodeIndex = edgeB.nodeIndex();\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const valueB = (nodeB as any)[fieldName]();\n\n      const result = valueA < valueB ? -1 : (valueA > valueB ? 1 : 0);\n      return ascending ? result : -result;\n    }\n\n    function compareEdgeAndEdge(indexA: number, indexB: number): number {\n      let result = compareEdgeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareEdgeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareEdgeAndNode(indexA: number, indexB: number): number {\n      let result = compareEdgeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareNodeAndEdge(indexA: number, indexB: number): number {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareEdgeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareNodeAndNode(indexA: number, indexB: number): number {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    function isEdgeFieldName(fieldName: string): boolean {\n      return fieldName.startsWith('!edge');\n    }\n\n    if (isEdgeFieldName(fieldName1)) {\n      if (isEdgeFieldName(fieldName2)) {\n        Platform.ArrayUtilities.sortRange(\n            this.iterationOrder, compareEdgeAndEdge, leftBound, rightBound, windowLeft, windowRight);\n      } else {\n        Platform.ArrayUtilities.sortRange(\n            this.iterationOrder, compareEdgeAndNode, leftBound, rightBound, windowLeft, windowRight);\n      }\n    } else if (isEdgeFieldName(fieldName2)) {\n      Platform.ArrayUtilities.sortRange(\n          this.iterationOrder, compareNodeAndEdge, leftBound, rightBound, windowLeft, windowRight);\n    } else {\n      Platform.ArrayUtilities.sortRange(\n          this.iterationOrder, compareNodeAndNode, leftBound, rightBound, windowLeft, windowRight);\n    }\n  }\n}\n\nexport class HeapSnapshotNodesProvider extends HeapSnapshotItemProvider {\n  snapshot: HeapSnapshot;\n  constructor(snapshot: HeapSnapshot, nodeIndexes: number[]|Uint32Array) {\n    const indexProvider = new HeapSnapshotNodeIndexProvider(snapshot);\n    const it = new HeapSnapshotIndexRangeIterator(indexProvider, nodeIndexes);\n    super(it, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  nodePosition(snapshotObjectId: number): number {\n    this.createIterationOrder();\n    const node = this.snapshot.createNode();\n    let i = 0;\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    for (; i < this.iterationOrder.length; i++) {\n      node.nodeIndex = this.iterationOrder[i];\n      if (node.id() === snapshotObjectId) {\n        break;\n      }\n    }\n    if (i === this.iterationOrder.length) {\n      return -1;\n    }\n    const targetNodeIndex = this.iterationOrder[i];\n    let smallerCount = 0;\n\n    const currentComparator = (this.currentComparator as HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig);\n    const compare = this.buildCompareFunction(currentComparator);\n    for (let i = 0; i < this.iterationOrder.length; i++) {\n      if (compare(this.iterationOrder[i], targetNodeIndex) < 0) {\n        ++smallerCount;\n      }\n    }\n    return smallerCount;\n  }\n\n  private buildCompareFunction(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig):\n      (arg0: number, arg1: number) => number {\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const fieldAccessor1 = (nodeA as any)[comparator.fieldName1];\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const fieldAccessor2 = (nodeA as any)[comparator.fieldName2];\n    const ascending1 = comparator.ascending1 ? 1 : -1;\n    const ascending2 = comparator.ascending2 ? 1 : -1;\n\n    function sortByNodeField(fieldAccessor: () => void, ascending: number): number {\n      const valueA = fieldAccessor.call(nodeA);\n      const valueB = fieldAccessor.call(nodeB);\n      return valueA < valueB ? -ascending : (valueA > valueB ? ascending : 0);\n    }\n\n    function sortByComparator(indexA: number, indexB: number): number {\n      nodeA.nodeIndex = indexA;\n      nodeB.nodeIndex = indexB;\n      let result = sortByNodeField(fieldAccessor1, ascending1);\n      if (result === 0) {\n        result = sortByNodeField(fieldAccessor2, ascending2);\n      }\n      return result || indexA - indexB;\n    }\n\n    return sortByComparator;\n  }\n\n  sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void {\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    Platform.ArrayUtilities.sortRange(\n        this.iterationOrder, this.buildCompareFunction(comparator), leftBound, rightBound, windowLeft, windowRight);\n  }\n}\n\nexport class JSHeapSnapshot extends HeapSnapshot {\n  readonly nodeFlags: {\n    // bit flags\n    canBeQueried: number,\n    detachedDOMTreeNode: number,\n    pageObject:\n        number,  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n  };\n  override lazyStringCache: {};\n  private flags!: Uint32Array;\n  #statistics?: HeapSnapshotModel.HeapSnapshotModel.Statistics;\n  #options: HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotOptions;\n  constructor(\n      profile: Profile, progress: HeapSnapshotProgress,\n      options?: HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotOptions) {\n    super(profile, progress);\n    this.nodeFlags = {\n      // bit flags\n      canBeQueried: 1,\n      detachedDOMTreeNode: 2,\n      pageObject:\n          4,  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n    };\n    this.lazyStringCache = {};\n    this.#options = options ?? {heapSnapshotTreatBackingStoreAsContainingObject: false};\n    this.initialize();\n  }\n\n  createNode(nodeIndex?: number): JSHeapSnapshotNode {\n    return new JSHeapSnapshotNode(this, nodeIndex === undefined ? -1 : nodeIndex);\n  }\n\n  createEdge(edgeIndex: number): JSHeapSnapshotEdge {\n    return new JSHeapSnapshotEdge(this, edgeIndex);\n  }\n\n  createRetainingEdge(retainerIndex: number): JSHeapSnapshotRetainerEdge {\n    return new JSHeapSnapshotRetainerEdge(this, retainerIndex);\n  }\n\n  override containmentEdgesFilter(): (arg0: HeapSnapshotEdge) => boolean {\n    return (edge: HeapSnapshotEdge): boolean => !edge.isInvisible();\n  }\n\n  override retainingEdgesFilter(): (arg0: HeapSnapshotEdge) => boolean {\n    const containmentEdgesFilter = this.containmentEdgesFilter();\n    function filter(edge: HeapSnapshotEdge): boolean {\n      return containmentEdgesFilter(edge) && !edge.node().isRoot() && !edge.isWeak();\n    }\n    return filter;\n  }\n\n  override calculateFlags(): void {\n    this.flags = new Uint32Array(this.nodeCount);\n    this.markDetachedDOMTreeNodes();\n    this.markQueriableHeapObjects();\n    this.markPageOwnedNodes();\n  }\n\n  // Updates the shallow sizes for \"owned\" objects of types kArray or kHidden to\n  // zero, and add their sizes to the \"owner\" object instead.\n  override calculateShallowSizes(): void {\n    if (!this.#options.heapSnapshotTreatBackingStoreAsContainingObject) {\n      return;\n    }\n\n    const {nodeCount, nodes, nodeFieldCount, nodeSelfSizeOffset} = this;\n\n    const kUnvisited = 0xffffffff;\n    const kHasMultipleOwners = 0xfffffffe;\n    if (nodeCount >= kHasMultipleOwners) {\n      throw new Error('Too many nodes for calculateShallowSizes');\n    }\n    // For each node in order, `owners` will contain the index of the owning\n    // node or one of the two values kUnvisited or kHasMultipleOwners. The\n    // indexes in this array are NOT already multiplied by nodeFieldCount.\n    const owners = new Uint32Array(nodeCount);\n    // The worklist contains the indexes of nodes which should be visited during\n    // the second loop below. The order of visiting doesn't matter. The indexes\n    // in this array are NOT already multiplied by nodeFieldCount.\n    const worklist: number[] = [];\n\n    const node = this.createNode(0);\n    for (let i = 0; i < nodeCount; ++i) {\n      if (node.isHidden() || node.isArray()) {\n        owners[i] = kUnvisited;\n      } else {\n        // The node owns itself.\n        owners[i] = i;\n        worklist.push(i);\n      }\n      node.nodeIndex = node.nextNodeIndex();\n    }\n\n    while (worklist.length !== 0) {\n      const id = worklist.pop() as number;\n      const owner = owners[id];\n      node.nodeIndex = id * nodeFieldCount;\n      for (let iter = node.edges(); iter.hasNext(); iter.next()) {\n        const edge = iter.edge;\n        if (edge.isWeak()) {\n          continue;\n        }\n        const targetId = edge.nodeIndex() / nodeFieldCount;\n        switch (owners[targetId]) {\n          case kUnvisited:\n            owners[targetId] = owner;\n            worklist.push(targetId);\n            break;\n          case targetId:\n          case owner:\n          case kHasMultipleOwners:\n            // There is no change necessary if the target is already marked as:\n            // * owned by itself,\n            // * owned by the owner of the current source node, or\n            // * owned by multiple nodes.\n            break;\n          default:\n            owners[targetId] = kHasMultipleOwners;\n            // It is possible that this node is already in the worklist\n            // somewhere, but visiting it an extra time is not harmful. The\n            // iteration is guaranteed to complete because each node can only be\n            // added twice to the worklist: once when changing from kUnvisited\n            // to a specific owner, and a second time when changing from that\n            // owner to kHasMultipleOwners.\n            worklist.push(targetId);\n            break;\n        }\n      }\n    }\n\n    for (let i = 0; i < nodeCount; ++i) {\n      const ownerId = owners[i];\n      switch (ownerId) {\n        case kUnvisited:\n        case kHasMultipleOwners:\n        case i:\n          break;\n        default: {\n          const ownedNodeIndex = i * nodeFieldCount;\n          const ownerNodeIndex = ownerId * nodeFieldCount;\n          node.nodeIndex = ownerNodeIndex;\n          if (node.isSynthetic()) {\n            // Adding shallow size to synthetic nodes is not useful.\n            break;\n          }\n          const sizeToTransfer = nodes.getValue(ownedNodeIndex + nodeSelfSizeOffset);\n          nodes.setValue(ownedNodeIndex + nodeSelfSizeOffset, 0);\n          nodes.setValue(\n              ownerNodeIndex + nodeSelfSizeOffset,\n              nodes.getValue(ownerNodeIndex + nodeSelfSizeOffset) + sizeToTransfer);\n          break;\n        }\n      }\n    }\n  }\n\n  override calculateDistances(isForRetainersView: boolean): void {\n    const pendingEphemeronEdges = new Set<string>();\n    function filter(node: HeapSnapshotNode, edge: HeapSnapshotEdge): boolean {\n      if (node.isHidden() && edge.name() === 'sloppy_function_map' && node.rawName() === 'system / NativeContext') {\n        return false;\n      }\n      if (node.isArray() && node.rawName() === '(map descriptors)') {\n        // DescriptorArrays are fixed arrays used to hold instance descriptors.\n        // The format of the these objects is:\n        //   [0]: Number of descriptors\n        //   [1]: Either Smi(0) if uninitialized, or a pointer to small fixed array:\n        //          [0]: pointer to fixed array with enum cache\n        //          [1]: either Smi(0) or pointer to fixed array with indices\n        //   [i*3+2]: i-th key\n        //   [i*3+3]: i-th type\n        //   [i*3+4]: i-th descriptor\n        // As long as maps may share descriptor arrays some of the descriptor\n        // links may not be valid for all the maps. We just skip\n        // all the descriptor links when calculating distances.\n        // For more details see http://crbug.com/413608\n        const index = parseInt(edge.name(), 10);\n        return index < 2 || (index % 3) !== 1;\n      }\n      if (edge.isInternal()) {\n        // Snapshots represent WeakMap values as being referenced by two edges:\n        // one from the WeakMap, and a second from the corresponding key. To\n        // avoid the case described in crbug.com/1290800, we should set the\n        // distance of that value to the greater of (WeakMap+1, key+1). This\n        // part of the filter skips the first edge in the matched pair of edges,\n        // so that the distance gets set based on the second, which should be\n        // greater or equal due to traversal order.\n        const match = HeapSnapshot.tryParseWeakMapEdgeName(edge.name());\n        if (match) {\n          if (!pendingEphemeronEdges.delete(match.duplicatedPart)) {\n            pendingEphemeronEdges.add(match.duplicatedPart);\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    super.calculateDistances(isForRetainersView, filter);\n  }\n\n  override isUserRoot(node: HeapSnapshotNode): boolean {\n    return node.isUserRoot() || node.isDocumentDOMTreesRoot();\n  }\n\n  override userObjectsMapAndFlag(): {map: Uint32Array, flag: number}|null {\n    return {map: this.flags, flag: this.nodeFlags.pageObject};\n  }\n\n  flagsOfNode(node: HeapSnapshotNode): number {\n    return this.flags[node.nodeIndex / this.nodeFieldCount];\n  }\n\n  private markDetachedDOMTreeNodes(): void {\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodeNativeType = this.nodeNativeType;\n    const nodeTypeOffset = this.nodeTypeOffset;\n    const flag = this.nodeFlags.detachedDOMTreeNode;\n    const node = this.rootNode();\n    for (let nodeIndex = 0, ordinal = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount, ordinal++) {\n      const nodeType = nodes.getValue(nodeIndex + nodeTypeOffset);\n      if (nodeType !== nodeNativeType) {\n        continue;\n      }\n      node.nodeIndex = nodeIndex;\n      if (node.name().startsWith('Detached ')) {\n        this.flags[ordinal] |= flag;\n      }\n    }\n  }\n\n  private markQueriableHeapObjects(): void {\n    // Allow runtime properties query for objects accessible from Window objects\n    // via regular properties, and for DOM wrappers. Trying to access random objects\n    // can cause a crash due to inconsistent state of internal properties of wrappers.\n    const flag = this.nodeFlags.canBeQueried;\n    const hiddenEdgeType = this.edgeHiddenType;\n    const internalEdgeType = this.edgeInternalType;\n    const invisibleEdgeType = this.edgeInvisibleType;\n    const weakEdgeType = this.edgeWeakType;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this.nodeFieldCount;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n\n    const flags = (this.flags as Uint32Array);\n    const list: number[] = [];\n\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      if (iter.edge.node().isUserRoot()) {\n        list.push(iter.edge.node().nodeIndex / nodeFieldCount);\n      }\n    }\n\n    while (list.length) {\n      const nodeOrdinal = (list.pop() as number);\n      if (flags[nodeOrdinal] & flag) {\n        continue;\n      }\n      flags[nodeOrdinal] |= flag;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & flag) {\n          continue;\n        }\n        const type = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n        if (type === hiddenEdgeType || type === invisibleEdgeType || type === internalEdgeType ||\n            type === weakEdgeType) {\n          continue;\n        }\n        list.push(childNodeOrdinal);\n      }\n    }\n  }\n\n  private markPageOwnedNodes(): void {\n    const edgeShortcutType = this.edgeShortcutType;\n    const edgeElementType = this.edgeElementType;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeWeakType = this.edgeWeakType;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodesCount = this.nodeCount;\n\n    const flags = (this.flags as Uint32Array);\n    const pageObjectFlag = this.nodeFlags.pageObject;\n\n    const nodesToVisit = new Uint32Array(nodesCount);\n    let nodesToVisitLength = 0;\n\n    const rootNodeOrdinal = this.rootNodeIndexInternal / nodeFieldCount;\n    const node = this.rootNode();\n\n    // Populate the entry points. They are Window objects and DOM Tree Roots.\n    for (let edgeIndex = firstEdgeIndexes[rootNodeOrdinal], endEdgeIndex = firstEdgeIndexes[rootNodeOrdinal + 1];\n         edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n      const nodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n      if (edgeType === edgeElementType) {\n        node.nodeIndex = nodeIndex;\n        if (!node.isDocumentDOMTreesRoot()) {\n          continue;\n        }\n      } else if (edgeType !== edgeShortcutType) {\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      nodesToVisit[nodesToVisitLength++] = nodeOrdinal;\n      flags[nodeOrdinal] |= pageObjectFlag;\n    }\n\n    // Mark everything reachable with the pageObject flag.\n    while (nodesToVisitLength) {\n      const nodeOrdinal = nodesToVisit[--nodesToVisitLength];\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & pageObjectFlag) {\n          continue;\n        }\n        const type = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n        if (type === edgeWeakType) {\n          continue;\n        }\n        nodesToVisit[nodesToVisitLength++] = childNodeOrdinal;\n        flags[childNodeOrdinal] |= pageObjectFlag;\n      }\n    }\n  }\n\n  override calculateStatistics(): void {\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeTypeOffset = this.nodeTypeOffset;\n    const nodeSizeOffset = this.nodeSelfSizeOffset;\n    const nodeNativeType = this.nodeNativeType;\n    const nodeCodeType = this.nodeCodeType;\n    const nodeConsStringType = this.nodeConsStringType;\n    const nodeSlicedStringType = this.nodeSlicedStringType;\n    const distances = this.nodeDistances;\n    let sizeNative = 0;\n    let sizeCode = 0;\n    let sizeStrings = 0;\n    let sizeJSArrays = 0;\n    let sizeSystem = 0;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nodeSize = nodes.getValue(nodeIndex + nodeSizeOffset);\n      const ordinal = nodeIndex / nodeFieldCount;\n      if (distances[ordinal] >= HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance) {\n        sizeSystem += nodeSize;\n        continue;\n      }\n      const nodeType = nodes.getValue(nodeIndex + nodeTypeOffset);\n      node.nodeIndex = nodeIndex;\n      if (nodeType === nodeNativeType) {\n        sizeNative += nodeSize;\n      } else if (nodeType === nodeCodeType) {\n        sizeCode += nodeSize;\n      } else if (nodeType === nodeConsStringType || nodeType === nodeSlicedStringType || node.type() === 'string') {\n        sizeStrings += nodeSize;\n      } else if (node.name() === 'Array') {\n        sizeJSArrays += this.calculateArraySize(node);\n      }\n    }\n    this.#statistics = new HeapSnapshotModel.HeapSnapshotModel.Statistics();\n    this.#statistics.total = this.totalSize;\n    this.#statistics.v8heap = this.totalSize - sizeNative;\n    this.#statistics.native = sizeNative;\n    this.#statistics.code = sizeCode;\n    this.#statistics.jsArrays = sizeJSArrays;\n    this.#statistics.strings = sizeStrings;\n    this.#statistics.system = sizeSystem;\n  }\n\n  private calculateArraySize(node: HeapSnapshotNode): number {\n    let size = node.selfSize();\n    const beginEdgeIndex = node.edgeIndexesStart();\n    const endEdgeIndex = node.edgeIndexesEnd();\n    const containmentEdges = this.containmentEdges;\n    const strings = this.strings;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeNameOffset = this.edgeNameOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeInternalType = this.edgeInternalType;\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n      if (edgeType !== edgeInternalType) {\n        continue;\n      }\n      const edgeName = strings[containmentEdges.getValue(edgeIndex + edgeNameOffset)];\n      if (edgeName !== 'elements') {\n        continue;\n      }\n      const elementsNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n      node.nodeIndex = elementsNodeIndex;\n      if (node.retainersCount() === 1) {\n        size += node.selfSize();\n      }\n      break;\n    }\n    return size;\n  }\n\n  getStatistics(): HeapSnapshotModel.HeapSnapshotModel.Statistics {\n    return this.#statistics as HeapSnapshotModel.HeapSnapshotModel.Statistics;\n  }\n}\n\nexport class JSHeapSnapshotNode extends HeapSnapshotNode {\n  constructor(snapshot: JSHeapSnapshot, nodeIndex?: number) {\n    super(snapshot, nodeIndex);\n  }\n\n  canBeQueried(): boolean {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    const flags = snapshot.flagsOfNode(this);\n    return Boolean(flags & snapshot.nodeFlags.canBeQueried);\n  }\n\n  override rawName(): string {\n    return super.name();\n  }\n\n  override name(): string {\n    const snapshot = this.snapshot;\n    if (this.rawType() === snapshot.nodeConsStringType) {\n      let string: string = snapshot.lazyStringCache[this.nodeIndex];\n      if (typeof string === 'undefined') {\n        string = this.consStringName();\n        snapshot.lazyStringCache[this.nodeIndex] = string;\n      }\n      return string;\n    }\n    return this.rawName();\n  }\n\n  private consStringName(): string {\n    const snapshot = this.snapshot;\n    const consStringType = snapshot.nodeConsStringType;\n    const edgeInternalType = snapshot.edgeInternalType;\n    const edgeFieldsCount = snapshot.edgeFieldsCount;\n    const edgeToNodeOffset = snapshot.edgeToNodeOffset;\n    const edgeTypeOffset = snapshot.edgeTypeOffset;\n    const edgeNameOffset = snapshot.edgeNameOffset;\n    const strings = snapshot.strings;\n    const edges = snapshot.containmentEdges;\n    const firstEdgeIndexes = snapshot.firstEdgeIndexes;\n    const nodeFieldCount = snapshot.nodeFieldCount;\n    const nodeTypeOffset = snapshot.nodeTypeOffset;\n    const nodeNameOffset = snapshot.nodeNameOffset;\n    const nodes = snapshot.nodes;\n    const nodesStack = [];\n    nodesStack.push(this.nodeIndex);\n    let name = '';\n\n    while (nodesStack.length && name.length < 1024) {\n      const nodeIndex = (nodesStack.pop() as number);\n      if (nodes.getValue(nodeIndex + nodeTypeOffset) !== consStringType) {\n        name += strings[nodes.getValue(nodeIndex + nodeNameOffset)];\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      let firstNodeIndex = 0;\n      let secondNodeIndex = 0;\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex && (!firstNodeIndex || !secondNodeIndex);\n           edgeIndex += edgeFieldsCount) {\n        const edgeType = edges.getValue(edgeIndex + edgeTypeOffset);\n        if (edgeType === edgeInternalType) {\n          const edgeName = strings[edges.getValue(edgeIndex + edgeNameOffset)];\n          if (edgeName === 'first') {\n            firstNodeIndex = edges.getValue(edgeIndex + edgeToNodeOffset);\n          } else if (edgeName === 'second') {\n            secondNodeIndex = edges.getValue(edgeIndex + edgeToNodeOffset);\n          }\n        }\n      }\n      nodesStack.push(secondNodeIndex);\n      nodesStack.push(firstNodeIndex);\n    }\n    return name;\n  }\n\n  override className(): string {\n    const type = this.type();\n    switch (type) {\n      case 'hidden':\n        return '(system)';\n      case 'object':\n      case 'native':\n        return this.name();\n      case 'code':\n        return '(compiled code)';\n      case 'closure':\n        return 'Function';\n      case 'regexp':\n        return 'RegExp';\n      default:\n        return '(' + type + ')';\n    }\n  }\n\n  override classIndex(): number {\n    const snapshot = this.snapshot;\n    const nodes = snapshot.nodes;\n    const type = nodes.getValue(this.nodeIndex + snapshot.nodeTypeOffset);\n    if (type === snapshot.nodeObjectType || type === snapshot.nodeNativeType) {\n      return nodes.getValue(this.nodeIndex + snapshot.nodeNameOffset);\n    }\n    return -1 - type;\n  }\n\n  override id(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeIdOffset);\n  }\n\n  override isHidden(): boolean {\n    return this.rawType() === this.snapshot.nodeHiddenType;\n  }\n\n  override isArray(): boolean {\n    return this.rawType() === this.snapshot.nodeArrayType;\n  }\n\n  override isSynthetic(): boolean {\n    return this.rawType() === this.snapshot.nodeSyntheticType;\n  }\n\n  override isUserRoot(): boolean {\n    return !this.isSynthetic();\n  }\n\n  override isDocumentDOMTreesRoot(): boolean {\n    return this.isSynthetic() && this.name() === '(Document DOM trees)';\n  }\n\n  override serialize(): HeapSnapshotModel.HeapSnapshotModel.Node {\n    const result = super.serialize();\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    const flags = snapshot.flagsOfNode(this);\n    if (flags & snapshot.nodeFlags.canBeQueried) {\n      result.canBeQueried = true;\n    }\n    if (flags & snapshot.nodeFlags.detachedDOMTreeNode) {\n      result.detachedDOMTreeNode = true;\n    }\n    return result;\n  }\n}\n\nexport class JSHeapSnapshotEdge extends HeapSnapshotEdge {\n  constructor(snapshot: JSHeapSnapshot, edgeIndex?: number) {\n    super(snapshot, edgeIndex);\n  }\n\n  override clone(): JSHeapSnapshotEdge {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    return new JSHeapSnapshotEdge(snapshot, this.edgeIndex);\n  }\n\n  override hasStringName(): boolean {\n    if (!this.isShortcut()) {\n      return this.hasStringNameInternal();\n    }\n    // @ts-ignore parseInt is successful against numbers.\n    return isNaN(parseInt(this.nameInternal(), 10));\n  }\n\n  isElement(): boolean {\n    return this.rawType() === this.snapshot.edgeElementType;\n  }\n\n  isHidden(): boolean {\n    return this.rawType() === this.snapshot.edgeHiddenType;\n  }\n\n  override isWeak(): boolean {\n    return this.rawType() === this.snapshot.edgeWeakType;\n  }\n\n  override isInternal(): boolean {\n    return this.rawType() === this.snapshot.edgeInternalType;\n  }\n\n  override isInvisible(): boolean {\n    return this.rawType() === this.snapshot.edgeInvisibleType;\n  }\n\n  isShortcut(): boolean {\n    return this.rawType() === this.snapshot.edgeShortcutType;\n  }\n\n  override name(): string {\n    const name = this.nameInternal();\n    if (!this.isShortcut()) {\n      return String(name);\n    }\n    // @ts-ignore parseInt is successful against numbers.\n    const numName = parseInt(name, 10);\n    return String(isNaN(numName) ? name : numName);\n  }\n\n  override toString(): string {\n    const name = this.name();\n    switch (this.type()) {\n      case 'context':\n        return '->' + name;\n      case 'element':\n        return '[' + name + ']';\n      case 'weak':\n        return '[[' + name + ']]';\n      case 'property':\n        return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n      case 'shortcut':\n        if (typeof name === 'string') {\n          return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n        }\n        return '[' + name + ']';\n      case 'internal':\n      case 'hidden':\n      case 'invisible':\n        return '{' + name + '}';\n    }\n    return '?' + name + '?';\n  }\n\n  private hasStringNameInternal(): boolean {\n    const type = this.rawType();\n    const snapshot = this.snapshot;\n    return type !== snapshot.edgeElementType && type !== snapshot.edgeHiddenType;\n  }\n\n  private nameInternal(): string|number {\n    return this.hasStringNameInternal() ? this.snapshot.strings[this.nameOrIndex()] : this.nameOrIndex();\n  }\n\n  private nameOrIndex(): number {\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeNameOffset);\n  }\n\n  override rawType(): number {\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeTypeOffset);\n  }\n}\n\nexport class JSHeapSnapshotRetainerEdge extends HeapSnapshotRetainerEdge {\n  constructor(snapshot: JSHeapSnapshot, retainerIndex: number) {\n    super(snapshot, retainerIndex);\n  }\n\n  override clone(): JSHeapSnapshotRetainerEdge {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    return new JSHeapSnapshotRetainerEdge(snapshot, this.retainerIndex());\n  }\n\n  isHidden(): boolean {\n    return this.edge().isHidden();\n  }\n\n  isInvisible(): boolean {\n    return this.edge().isInvisible();\n  }\n\n  isShortcut(): boolean {\n    return this.edge().isShortcut();\n  }\n\n  isWeak(): boolean {\n    return this.edge().isWeak();\n  }\n}\nexport interface AggregatedInfo {\n  count: number;\n  distance: number;\n  self: number;\n  maxRet: number;\n  name: string|null;\n  idxs: number[];\n}\n","/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {ContentData, type ContentDataOrError} from './ContentData.js';\nimport {SearchMatch} from './ContentProvider.js';\nimport {Text} from './Text.js';\n\nconst KEY_VALUE_FILTER_REGEXP = /(?:^|\\s)(\\-)?([\\w\\-]+):([^\\s]+)/;\nconst REGEXP_FILTER_REGEXP = /(?:^|\\s)(\\-)?\\/([^\\/\\\\]+(\\\\.[^\\/]*)*)\\//;\nconst TEXT_FILTER_REGEXP = /(?:^|\\s)(\\-)?([^\\s]+)/;\nconst SPACE_CHAR_REGEXP = /\\s/;\n\nexport const Utils = {\n  isSpaceChar: function(char: string): boolean {\n    return SPACE_CHAR_REGEXP.test(char);\n  },\n\n  lineIndent: function(line: string): string {\n    let indentation = 0;\n    while (indentation < line.length && Utils.isSpaceChar(line.charAt(indentation))) {\n      ++indentation;\n    }\n    return line.substr(0, indentation);\n  },\n\n  splitStringByRegexes(text: string, regexes: RegExp[]): {\n    value: string,\n    position: number,\n    regexIndex: number,\n    captureGroups: Array<string|undefined>,\n  }[] {\n    const matches: {\n      value: string,\n      position: number,\n      regexIndex: number,\n      captureGroups: (string|undefined)[],\n    }[] = [];\n    const globalRegexes: RegExp[] = [];\n    for (let i = 0; i < regexes.length; i++) {\n      const regex = regexes[i];\n      if (!regex.global) {\n        globalRegexes.push(new RegExp(regex.source, regex.flags ? regex.flags + 'g' : 'g'));\n      } else {\n        globalRegexes.push(regex);\n      }\n    }\n    doSplit(text, 0, 0);\n    return matches;\n\n    function doSplit(text: string, regexIndex: number, startIndex: number): void {\n      if (regexIndex >= globalRegexes.length) {\n        // Set regexIndex as -1 if text did not match with any regular expression\n        matches.push({value: text, position: startIndex, regexIndex: -1, captureGroups: []});\n        return;\n      }\n      const regex = globalRegexes[regexIndex];\n      let currentIndex = 0;\n      let result;\n      regex.lastIndex = 0;\n      while ((result = regex.exec(text)) !== null) {\n        const stringBeforeMatch = text.substring(currentIndex, result.index);\n        if (stringBeforeMatch) {\n          doSplit(stringBeforeMatch, regexIndex + 1, startIndex + currentIndex);\n        }\n        const match = result[0];\n        matches.push({\n          value: match,\n          position: startIndex + result.index,\n          regexIndex: regexIndex,\n          captureGroups: result.slice(1),\n        });\n        currentIndex = result.index + match.length;\n      }\n      const stringAfterMatches = text.substring(currentIndex);\n      if (stringAfterMatches) {\n        doSplit(stringAfterMatches, regexIndex + 1, startIndex + currentIndex);\n      }\n    }\n  },\n};\n\nexport class FilterParser {\n  private readonly keys: string[];\n  constructor(keys: string[]) {\n    this.keys = keys;\n  }\n\n  static cloneFilter(filter: ParsedFilter): ParsedFilter {\n    return {key: filter.key, text: filter.text, regex: filter.regex, negative: filter.negative};\n  }\n\n  parse(query: string): ParsedFilter[] {\n    const splitFilters =\n        Utils.splitStringByRegexes(query, [KEY_VALUE_FILTER_REGEXP, REGEXP_FILTER_REGEXP, TEXT_FILTER_REGEXP]);\n    const parsedFilters: ParsedFilter[] = [];\n    for (const {regexIndex, captureGroups} of splitFilters) {\n      if (regexIndex === -1) {\n        continue;\n      }\n      if (regexIndex === 0) {\n        const startsWithMinus = captureGroups[0];\n        const parsedKey = captureGroups[1];\n        const parsedValue = captureGroups[2];\n        if (this.keys.indexOf((parsedKey as string)) !== -1) {\n          parsedFilters.push({\n            key: parsedKey,\n            regex: undefined,\n            text: parsedValue,\n            negative: Boolean(startsWithMinus),\n          });\n        } else {\n          parsedFilters.push({\n            key: undefined,\n            regex: undefined,\n            text: `${parsedKey}:${parsedValue}`,\n            negative: Boolean(startsWithMinus),\n          });\n        }\n      } else if (regexIndex === 1) {\n        const startsWithMinus = captureGroups[0];\n        const parsedRegex = captureGroups[1];\n        try {\n          parsedFilters.push({\n            key: undefined,\n            regex: new RegExp((parsedRegex as string), 'i'),\n            text: undefined,\n            negative: Boolean(startsWithMinus),\n          });\n        } catch (e) {\n          parsedFilters.push({\n            key: undefined,\n            regex: undefined,\n            text: `/${parsedRegex}/`,\n            negative: Boolean(startsWithMinus),\n          });\n        }\n      } else if (regexIndex === 2) {\n        const startsWithMinus = captureGroups[0];\n        const parsedText = captureGroups[1];\n        parsedFilters.push({\n          key: undefined,\n          regex: undefined,\n          text: parsedText,\n          negative: Boolean(startsWithMinus),\n        });\n      }\n    }\n    return parsedFilters;\n  }\n}\n\nexport class BalancedJSONTokenizer {\n  private readonly callback: (arg0: string) => void;\n  private index: number;\n  private balance: number;\n  private buffer: string;\n  private findMultiple: boolean;\n  private closingDoubleQuoteRegex: RegExp;\n  private lastBalancedIndex?: number;\n  constructor(callback: (arg0: string) => void, findMultiple?: boolean) {\n    this.callback = callback;\n    this.index = 0;\n    this.balance = 0;\n    this.buffer = '';\n    this.findMultiple = findMultiple || false;\n    this.closingDoubleQuoteRegex = /[^\\\\](?:\\\\\\\\)*\"/g;\n  }\n\n  write(chunk: string): boolean {\n    this.buffer += chunk;\n    const lastIndex = this.buffer.length;\n    const buffer = this.buffer;\n    let index;\n    for (index = this.index; index < lastIndex; ++index) {\n      const character = buffer[index];\n      if (character === '\"') {\n        this.closingDoubleQuoteRegex.lastIndex = index;\n        if (!this.closingDoubleQuoteRegex.test(buffer)) {\n          break;\n        }\n        index = this.closingDoubleQuoteRegex.lastIndex - 1;\n      } else if (character === '{') {\n        ++this.balance;\n      } else if (character === '}') {\n        --this.balance;\n        if (this.balance < 0) {\n          this.reportBalanced();\n          return false;\n        }\n        if (!this.balance) {\n          this.lastBalancedIndex = index + 1;\n          if (!this.findMultiple) {\n            break;\n          }\n        }\n      } else if (character === ']' && !this.balance) {\n        this.reportBalanced();\n        return false;\n      }\n    }\n    this.index = index;\n    this.reportBalanced();\n    return true;\n  }\n\n  private reportBalanced(): void {\n    if (!this.lastBalancedIndex) {\n      return;\n    }\n    this.callback(this.buffer.slice(0, this.lastBalancedIndex));\n    this.buffer = this.buffer.slice(this.lastBalancedIndex);\n    this.index -= this.lastBalancedIndex;\n    this.lastBalancedIndex = 0;\n  }\n\n  remainder(): string {\n    return this.buffer;\n  }\n}\n\n/**\n * Detects the indentation used by a given text document, based on the _Comparing\n * lines_ approach suggested by Heather Arthur (and also found in Firefox DevTools).\n *\n * This implementation differs from the original proposal in that tab indentation\n * isn't detected by checking if at least 50% of the lines start with a tab, but\n * instead by comparing the number of lines that start with a tab to the frequency\n * of the other indentation patterns. This way we also detect small snippets with\n * long leading comments correctly, when tab indentation is used for the snippets\n * of code.\n *\n * @param lines The input document lines.\n * @return The indentation detected for the lines as string or `null` if it's inconclusive.\n *\n * @see https://heathermoor.medium.com/detecting-code-indentation-eff3ed0fb56b\n */\nexport const detectIndentation = function(lines: Iterable<string>): string|null {\n  const frequencies: Array<number> = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n  let tabs = 0, previous = 0;\n\n  for (const line of lines) {\n    let current = 0;\n    if (line.length !== 0) {\n      let char = line.charAt(0);\n      if (char === '\\t') {\n        tabs++;\n        continue;\n      }\n      while (char === ' ') {\n        char = line.charAt(++current);\n      }\n    }\n\n    if (current === line.length) {\n      // Don't consider empty lines.\n      previous = 0;\n      continue;\n    }\n\n    const delta = Math.abs(current - previous);\n    if (delta < frequencies.length) {\n      // Don't consider deltas above 8 characters.\n      frequencies[delta] = frequencies[delta] + 1;\n    }\n    previous = current;\n  }\n\n  // Find most frequent non-zero width difference between adjacent lines.\n  let mostFrequentDelta = 0, highestFrequency = 0;\n  for (let delta = 1; delta < frequencies.length; ++delta) {\n    const frequency = frequencies[delta];\n    if (frequency > highestFrequency) {\n      highestFrequency = frequency;\n      mostFrequentDelta = delta;\n    }\n  }\n\n  if (tabs > mostFrequentDelta) {\n    // If more lines start with tabs than any other indentation,\n    // we assume that the document was written with tab indentation\n    // in mind. This differs from the original algorithm.\n    return '\\t';\n  }\n\n  if (!mostFrequentDelta) {\n    return null;\n  }\n\n  return ' '.repeat(mostFrequentDelta);\n};\n\n/**\n * Heuristic to check whether a given text was likely minified. Intended to\n * be used for HTML, CSS, and JavaScript inputs.\n *\n * A text is considered to be the result of minification if the average\n * line length for the whole text is 80 characters or more.\n *\n * @param text The input text to check.\n * @returns\n */\nexport const isMinified = function(text: string): boolean {\n  let lineCount = 0;\n  for (let lastIndex = 0; lastIndex < text.length; ++lineCount) {\n    let eolIndex = text.indexOf('\\n', lastIndex);\n    if (eolIndex < 0) {\n      eolIndex = text.length;\n    }\n    lastIndex = eolIndex + 1;\n  }\n  return (text.length - lineCount) / lineCount >= 80;\n};\n\n/**\n * Small wrapper around {@link performSearchInContent} to reduce boilerplate when searching\n * in {@link ContentDataOrError}.\n *\n * @returns empty search matches if `contentData` is an error or not text content.\n */\nexport const performSearchInContentData = function(\n    contentData: ContentDataOrError, query: string, caseSensitive: boolean, isRegex: boolean): SearchMatch[] {\n  if (ContentData.isError(contentData) || !contentData.isTextContent) {\n    return [];\n  }\n  return performSearchInContent(contentData.text, query, caseSensitive, isRegex);\n};\n\n/**\n * @returns One {@link SearchMatch} per match. Multiple matches on the same line each\n * result in their own `SearchMatchExact` instance.\n */\nexport const performSearchInContent = function(\n    content: string, query: string, caseSensitive: boolean, isRegex: boolean): SearchMatch[] {\n  const regex = Platform.StringUtilities.createSearchRegex(query, caseSensitive, isRegex);\n\n  const text = new Text(content);\n  const result = [];\n  for (let i = 0; i < text.lineCount(); ++i) {\n    const lineContent = text.lineAt(i);\n    const matches = lineContent.matchAll(regex);\n    for (const match of matches) {\n      result.push(new SearchMatch(i, lineContent, match.index as number, match[0].length));\n    }\n  }\n  return result;\n};\n\n/**\n * Similar to {@link performSearchInContent} but doesn't search in a whole text but rather\n * finds the exact matches on a prelminiary search result (i.e. lines with known matches).\n * @param matches is deliberatedly typed as an object literal so we can pass the\n *                CDP search result type.\n */\nexport const performSearchInSearchMatches = function(\n    matches: {lineNumber: number, lineContent: string}[], query: string, caseSensitive: boolean,\n    isRegex: boolean): SearchMatch[] {\n  const regex = Platform.StringUtilities.createSearchRegex(query, caseSensitive, isRegex);\n  const result = [];\n\n  for (const {lineNumber, lineContent} of matches) {\n    const matches = lineContent.matchAll(regex);\n    for (const match of matches) {\n      result.push(new SearchMatch(lineNumber, lineContent, match.index as number, match[0].length));\n    }\n  }\n  return result;\n};\n\nexport interface ParsedFilter {\n  key?: string;\n  text?: string|null;\n  regex?: RegExp;\n  negative: boolean;\n}\n","// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nexport const BASE64_CODES = new Uint8Array(123);\nfor (let index = 0; index < BASE64_CHARS.length; ++index) {\n  BASE64_CODES[BASE64_CHARS.charCodeAt(index)] = index;\n}\n\n/**\n * Decodes Base64-encoded data from a string without performing any kind of checking.\n */\nexport function decode(input: string): ArrayBuffer {\n  let bytesLength = ((input.length * 3) / 4) >>> 0;\n  if (input.charCodeAt(input.length - 2) === 0x3d /* '=' */) {\n    bytesLength -= 2;\n  } else if (input.charCodeAt(input.length - 1) === 0x3d /* '=' */) {\n    bytesLength -= 1;\n  }\n\n  const bytes = new Uint8Array(bytesLength);\n  for (let index = 0, offset = 0; index < input.length; index += 4) {\n    const a = BASE64_CODES[input.charCodeAt(index + 0)];\n    const b = BASE64_CODES[input.charCodeAt(index + 1)];\n    const c = BASE64_CODES[input.charCodeAt(index + 2)];\n    const d = BASE64_CODES[input.charCodeAt(index + 3)];\n    bytes[offset++] = (a << 2) | (b >> 4);\n    bytes[offset++] = ((b & 0x0f) << 4) | (c >> 2);\n    bytes[offset++] = ((c & 0x03) << 6) | (d & 0x3f);\n  }\n  return bytes.buffer;\n}\n\nexport function encode(input: ArrayBuffer|Blob): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onerror = () => reject(new Error('failed to convert to base64'));\n    reader.onload = () => {\n      const blobAsUrl = reader.result as string;\n      const [, base64] = blobAsUrl.split(',', 2);\n      resolve(base64);\n    };\n\n    reader.readAsDataURL(new Blob([input]));\n  });\n}\n","// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../i18n/i18n.js';\nimport type * as Platform from '../platform/platform.js';\n\nconst UIStrings = {\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  elementsPanel: 'Elements panel',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  stylesSidebar: 'styles sidebar',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  changesDrawer: 'Changes drawer',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  issuesView: 'Issues view',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  networkPanel: 'Network panel',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  applicationPanel: 'Application panel',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  sourcesPanel: 'Sources panel',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  memoryInspectorPanel: 'Memory inspector panel',\n  /**\n   * @description The UI destination when revealing loaded resources through the Developer Resources Panel\n   */\n  developerResourcesPanel: 'Developer Resources panel',\n};\nconst str_ = i18n.i18n.registerUIStrings('core/common/Revealer.ts', UIStrings);\nconst i18nLazyString = i18n.i18n.getLazilyComputedLocalizedString.bind(undefined, str_);\n\n/**\n * Interface for global revealers, which are entities responsible for\n * dealing with revealing certain types of objects. For example, the\n * Sources panel will register a revealer for `UISourceCode` objects,\n * which will ensure that its visible in an editor tab.\n */\nexport interface Revealer<T> {\n  reveal(revealable: T, omitFocus?: boolean): Promise<void>;\n}\n\nlet revealerRegistry: RevealerRegistry|undefined;\n\n/**\n * Registration for revealers, which deals with keeping a list of all possible\n * revealers, lazily instantiating them as necessary and invoking their `reveal`\n * methods depending on the _context types_ they were registered for.\n *\n * @see Revealer\n */\nexport class RevealerRegistry {\n  private readonly registeredRevealers: RevealerRegistration<unknown>[] = [];\n\n  /**\n   * Yields the singleton instance, creating it on-demand when necessary.\n   *\n   * @returns the singleton instance.\n   */\n  static instance(): RevealerRegistry {\n    if (revealerRegistry === undefined) {\n      revealerRegistry = new RevealerRegistry();\n    }\n    return revealerRegistry;\n  }\n\n  /**\n   * Clears the singleton instance (if any).\n   */\n  static removeInstance(): void {\n    revealerRegistry = undefined;\n  }\n\n  /**\n   * Register a new `Revealer` as described by the `registration`.\n   *\n   * @param registration the description.\n   */\n  register(registration: RevealerRegistration<unknown>): void {\n    this.registeredRevealers.push(registration);\n  }\n\n  /**\n   * Reveals the `revealable`.\n   *\n   * @param revealable the object to reveal.\n   * @param omitFocus whether to omit focusing on the presentation of `revealable` afterwards.\n   */\n  async reveal(revealable: unknown, omitFocus: boolean): Promise<void> {\n    const revealers = await Promise.all(\n        this.getApplicableRegisteredRevealers(revealable).map(registration => registration.loadRevealer()));\n    if (revealers.length < 1) {\n      throw new Error(`No revealers found for ${revealable}`);\n    }\n    if (revealers.length > 1) {\n      throw new Error(`Conflicting reveals found for ${revealable}`);\n    }\n    return await revealers[0].reveal(revealable, omitFocus);\n  }\n\n  getApplicableRegisteredRevealers(revealable: unknown): RevealerRegistration<unknown>[] {\n    return this.registeredRevealers.filter(registration => {\n      for (const contextType of registration.contextTypes()) {\n        if (revealable instanceof contextType) {\n          return true;\n        }\n      }\n      return false;\n    });\n  }\n}\n\nexport function revealDestination(revealable: unknown): string|null {\n  const revealers = RevealerRegistry.instance().getApplicableRegisteredRevealers(revealable);\n  for (const {destination} of revealers) {\n    if (destination) {\n      return destination();\n    }\n  }\n  return null;\n}\n\n/**\n * Register a new `Revealer` as described by the `registration` on the singleton\n * {@link RevealerRegistry} instance.\n *\n * @param registration the description.\n */\nexport function registerRevealer<T>(registration: RevealerRegistration<T>): void {\n  RevealerRegistry.instance().register(registration);\n}\n\n/**\n * Reveals the `revealable` via the singleton {@link RevealerRegistry} instance.\n *\n * @param revealable the object to reveal.\n * @param omitFocus whether to omit focusing on the presentation of `revealable` afterwards.\n */\nexport async function reveal(revealable: unknown, omitFocus: boolean = false): Promise<void> {\n  await RevealerRegistry.instance().reveal(revealable, omitFocus);\n}\n\nexport interface RevealerRegistration<T> {\n  contextTypes: () => Array<abstract new(...any: any[]) => T>;\n  loadRevealer: () => Promise<Revealer<T>>;\n  destination?: RevealerDestination;\n}\n\nexport const RevealerDestination = {\n  DEVELOPER_RESOURCES_PANEL: i18nLazyString(UIStrings.developerResourcesPanel),\n  ELEMENTS_PANEL: i18nLazyString(UIStrings.elementsPanel),\n  STYLES_SIDEBAR: i18nLazyString(UIStrings.stylesSidebar),\n  CHANGES_DRAWER: i18nLazyString(UIStrings.changesDrawer),\n  ISSUES_VIEW: i18nLazyString(UIStrings.issuesView),\n  NETWORK_PANEL: i18nLazyString(UIStrings.networkPanel),\n  APPLICATION_PANEL: i18nLazyString(UIStrings.applicationPanel),\n  SOURCES_PANEL: i18nLazyString(UIStrings.sourcesPanel),\n  MEMORY_INSPECTOR_PANEL: i18nLazyString(UIStrings.memoryInspectorPanel),\n};\n\nexport type RevealerDestination = () => Platform.UIString.LocalizedString;\n","// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../i18n/i18n.js';\nimport type * as Platform from '../platform/platform.js';\nimport * as Root from '../root/root.js';\n\nimport {type SettingStorageType} from './Settings.js';\n\nconst UIStrings = {\n  /**\n   *@description Title of the Elements Panel\n   */\n  elements: 'Elements',\n  /**\n   *@description Text for DevTools appearance\n   */\n  appearance: 'Appearance',\n  /**\n   *@description Name of the Sources panel\n   */\n  sources: 'Sources',\n  /**\n   *@description Title of the Network tool\n   */\n  network: 'Network',\n  /**\n   *@description Text for the performance of something\n   */\n  performance: 'Performance',\n  /**\n   *@description Title of the Console tool\n   */\n  console: 'Console',\n  /**\n   *@description A title of the 'Persistence' setting category\n   */\n  persistence: 'Persistence',\n  /**\n   *@description Text that refers to the debugger\n   */\n  debugger: 'Debugger',\n  /**\n   *@description Text describing global shortcuts and settings that are available throughout the DevTools\n   */\n  global: 'Global',\n  /**\n   *@description Title of the Rendering tool\n   */\n  rendering: 'Rendering',\n  /**\n   *@description Title of a section on CSS Grid tooling\n   */\n  grid: 'Grid',\n  /**\n   *@description Text for the mobile platform, as opposed to desktop\n   */\n  mobile: 'Mobile',\n  /**\n   *@description Text for the memory of the page\n   */\n  memory: 'Memory',\n  /**\n   *@description Text for the extension of the page\n   */\n  extension: 'Extension',\n  /**\n   *@description Text for the adorner of the page\n   */\n  adorner: 'Adorner',\n  /**\n   * @description Header for the \"Sync\" section in the settings UI. The \"Sync\"\n   * section allows users to configure which DevTools data is synced via Chrome Sync.\n   */\n  sync: 'Sync',\n};\nconst str_ = i18n.i18n.registerUIStrings('core/common/SettingRegistration.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nlet registeredSettings: Array<SettingRegistration> = [];\nconst settingNameSet = new Set<string>();\n\nexport function registerSettingExtension(registration: SettingRegistration): void {\n  const settingName = registration.settingName;\n  if (settingNameSet.has(settingName)) {\n    throw new Error(`Duplicate setting name '${settingName}'`);\n  }\n  settingNameSet.add(settingName);\n  registeredSettings.push(registration);\n}\n\nexport function getRegisteredSettings(): Array<SettingRegistration> {\n  return registeredSettings.filter(\n      setting =>\n          Root.Runtime.Runtime.isDescriptorEnabled({experiment: setting.experiment, condition: setting.condition}));\n}\n\nexport function registerSettingsForTest(settings: Array<SettingRegistration>, forceReset: boolean = false): void {\n  if (registeredSettings.length === 0 || forceReset) {\n    registeredSettings = settings;\n    settingNameSet.clear();\n    for (const setting of settings) {\n      const settingName = setting.settingName;\n      if (settingNameSet.has(settingName)) {\n        throw new Error(`Duplicate setting name '${settingName}'`);\n      }\n      settingNameSet.add(settingName);\n    }\n  }\n}\n\nexport function resetSettings(): void {\n  registeredSettings = [];\n  settingNameSet.clear();\n}\n\nexport function maybeRemoveSettingExtension(settingName: string): boolean {\n  const settingIndex = registeredSettings.findIndex(setting => setting.settingName === settingName);\n  if (settingIndex < 0 || !settingNameSet.delete(settingName)) {\n    return false;\n  }\n  registeredSettings.splice(settingIndex, 1);\n  return true;\n}\n\nexport const enum SettingCategory {\n  NONE = '',  // `NONE` must be a falsy value. Legacy code uses if-checks for the category.\n  ELEMENTS = 'ELEMENTS',\n  APPEARANCE = 'APPEARANCE',\n  SOURCES = 'SOURCES',\n  NETWORK = 'NETWORK',\n  PERFORMANCE = 'PERFORMANCE',\n  CONSOLE = 'CONSOLE',\n  PERSISTENCE = 'PERSISTENCE',\n  DEBUGGER = 'DEBUGGER',\n  GLOBAL = 'GLOBAL',\n  RENDERING = 'RENDERING',\n  GRID = 'GRID',\n  MOBILE = 'MOBILE',\n  EMULATION = 'EMULATION',\n  MEMORY = 'MEMORY',\n  EXTENSIONS = 'EXTENSIONS',\n  ADORNER = 'ADORNER',\n  SYNC = 'SYNC',\n}\n\nexport function getLocalizedSettingsCategory(category: SettingCategory): Platform.UIString.LocalizedString {\n  switch (category) {\n    case SettingCategory.ELEMENTS:\n      return i18nString(UIStrings.elements);\n    case SettingCategory.APPEARANCE:\n      return i18nString(UIStrings.appearance);\n    case SettingCategory.SOURCES:\n      return i18nString(UIStrings.sources);\n    case SettingCategory.NETWORK:\n      return i18nString(UIStrings.network);\n    case SettingCategory.PERFORMANCE:\n      return i18nString(UIStrings.performance);\n    case SettingCategory.CONSOLE:\n      return i18nString(UIStrings.console);\n    case SettingCategory.PERSISTENCE:\n      return i18nString(UIStrings.persistence);\n    case SettingCategory.DEBUGGER:\n      return i18nString(UIStrings.debugger);\n    case SettingCategory.GLOBAL:\n      return i18nString(UIStrings.global);\n    case SettingCategory.RENDERING:\n      return i18nString(UIStrings.rendering);\n    case SettingCategory.GRID:\n      return i18nString(UIStrings.grid);\n    case SettingCategory.MOBILE:\n      return i18nString(UIStrings.mobile);\n    case SettingCategory.EMULATION:\n      return i18nString(UIStrings.console);\n    case SettingCategory.MEMORY:\n      return i18nString(UIStrings.memory);\n    case SettingCategory.EXTENSIONS:\n      return i18nString(UIStrings.extension);\n    case SettingCategory.ADORNER:\n      return i18nString(UIStrings.adorner);\n    case SettingCategory.NONE:\n      return i18n.i18n.lockedString('');\n    case SettingCategory.SYNC:\n      return i18nString(UIStrings.sync);\n  }\n}\n\nexport const enum SettingType {\n  ARRAY = 'array',\n  REGEX = 'regex',\n  ENUM = 'enum',\n  BOOLEAN = 'boolean',\n}\n\nexport interface RegExpSettingItem {\n  /**\n   * A regular expression matched against URLs for ignore listing.\n   */\n  pattern: string;\n  /**\n   * If true, ignore this rule.\n   */\n  disabled?: boolean;\n  /**\n   * When a rule is disabled due to requesting through a script's context menu\n   * that it no longer be ignore listed, this field is set to the URL of that\n   * script, so that if the user requests through the same context menu to\n   * enable ignore listing, the rule can be reenabled.\n   */\n  disabledForUrl?: Platform.DevToolsPath.UrlString;\n}\n\nexport interface SettingRegistration {\n  /**\n   * The category with which the setting is displayed in the UI.\n   */\n  category?: SettingCategory;\n  /**\n   * Used to sort on screen the settings that belong to the same category.\n   */\n  order?: number;\n  /**\n   * The title with which the setting is shown on screen.\n   */\n  title?: () => Platform.UIString.LocalizedString;\n  /**\n   * The identifier of the setting.\n   */\n  settingName: string;\n  /**\n   * Determines how the possible values of the setting are expressed.\n   *\n   * - If the setting can only be enabled and disabled use BOOLEAN\n   * - If the setting has a list of possible values use ENUM\n   * - If each setting value is a set of objects use ARRAY\n   * - If the setting value is a regular expression use REGEX\n   */\n  settingType: SettingType;\n  /**\n   * The value set by default to the setting.\n   */\n  defaultValue: unknown;\n  /**\n   * Words used to find a setting in the Command Menu.\n   */\n  tags?: Array<() => Platform.UIString.LocalizedString>;\n  /**\n   * The possible values the setting can have, each with a description composed of a title and an optional text.\n   */\n  options?: Array<SettingExtensionOption>;\n  /**\n   * Whether DevTools must be reloaded for a change in the setting to take effect.\n   */\n  reloadRequired?: boolean;\n  /**\n   * Determines if the setting value is stored in the global, local or session storage.\n   */\n  storageType?: SettingStorageType;\n  /**\n   * A condition that, when present in the queryParamsObject of Runtime, constraints the value\n   * of the setting to be changed only if the user set it.\n   */\n  userActionCondition?: string;\n  /**\n   * The name of the experiment a setting is associated with. Enabling and disabling the declared\n   * experiment will enable and disable the setting respectively.\n   */\n  experiment?: Root.Runtime.ExperimentName;\n  /**\n   * A condition is a function that will make the setting available if it\n   * returns true, and not available, otherwise. Make sure that objects you\n   * access from inside the condition function are ready at the time when the\n   * setting conditions are checked.\n   */\n  condition?: Root.Runtime.Condition;\n\n  /**\n   * A function that returns true if the setting should be disabled, along with\n   * the reason why.\n   */\n  disabledCondition?: () => DisabledConditionResult;\n\n  /**\n   * If a setting is deprecated, define this notice to show an appropriate warning according to the `warning` propertiy.\n   * If `disabled` is set, the setting will be disabled in the settings UI. In that case, `experiment` optionally can be\n   * set to link to an experiment (by experiment name). The information icon in the settings UI can then be clicked to\n   * jump to the experiment. If a setting is not disabled, the experiment entry will be ignored.\n   */\n  deprecationNotice?: {disabled: boolean, warning: () => Platform.UIString.LocalizedString, experiment?: string};\n}\ninterface LocalizedSettingExtensionOption {\n  value: boolean|string;\n  title: () => Platform.UIString.LocalizedString;\n  text?: () => Platform.UIString.LocalizedString;\n  raw?: false;\n}\ninterface RawSettingExtensionOption {\n  value: boolean|string;\n  title: () => Platform.UIString.LocalizedString;\n  /**\n   * Text used to describe the option. Must be localized if 'raw' is false.\n   */\n  text?: string;\n  raw: true;\n}\nexport type SettingExtensionOption = LocalizedSettingExtensionOption|RawSettingExtensionOption;\nexport type DisabledConditionResult = {\n  disabled: true,\n  reason: string,\n}|{disabled: false};\n","/*\n * Copyright (C) 2012 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Platform from '../../core/platform/platform.js';\nimport type * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\n\nimport {type HeapSnapshotHeader, HeapSnapshotProgress, JSHeapSnapshot, type Profile} from './HeapSnapshot.js';\nimport {type HeapSnapshotWorkerDispatcher} from './HeapSnapshotWorkerDispatcher.js';\n\nexport class HeapSnapshotLoader {\n  readonly #progress: HeapSnapshotProgress;\n  #buffer: string[];\n  #dataCallback: ((value: string|PromiseLike<string>) => void)|null;\n  #done: boolean;\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #snapshot?: {[x: string]: any};\n  #array!: Platform.TypedArrayUtilities.BigUint32Array|null;\n  #arrayIndex!: number;\n  #json: string = '';\n  constructor(dispatcher: HeapSnapshotWorkerDispatcher) {\n    this.#reset();\n    this.#progress = new HeapSnapshotProgress(dispatcher);\n    this.#buffer = [];\n    this.#dataCallback = null;\n    this.#done = false;\n    void this.#parseInput();\n  }\n\n  dispose(): void {\n    this.#reset();\n  }\n\n  #reset(): void {\n    this.#json = '';\n    this.#snapshot = undefined;\n  }\n\n  close(): void {\n    this.#done = true;\n    if (this.#dataCallback) {\n      this.#dataCallback('');\n    }\n  }\n\n  buildSnapshot(options: HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotOptions): JSHeapSnapshot {\n    this.#snapshot = this.#snapshot || {};\n\n    this.#progress.updateStatus('Processing snapshot');\n    const result = new JSHeapSnapshot((this.#snapshot as Profile), this.#progress, options);\n    this.#reset();\n    return result;\n  }\n\n  #parseUintArray(): boolean {\n    let index = 0;\n    const char0 = '0'.charCodeAt(0);\n    const char9 = '9'.charCodeAt(0);\n    const closingBracket = ']'.charCodeAt(0);\n    const length = this.#json.length;\n    while (true) {\n      while (index < length) {\n        const code = this.#json.charCodeAt(index);\n        if (char0 <= code && code <= char9) {\n          break;\n        } else if (code === closingBracket) {\n          this.#json = this.#json.slice(index + 1);\n          return false;\n        }\n        ++index;\n      }\n      if (index === length) {\n        this.#json = '';\n        return true;\n      }\n      let nextNumber = 0;\n      const startIndex = index;\n      while (index < length) {\n        const code = this.#json.charCodeAt(index);\n        if (char0 > code || code > char9) {\n          break;\n        }\n        nextNumber *= 10;\n        nextNumber += (code - char0);\n        ++index;\n      }\n      if (index === length) {\n        this.#json = this.#json.slice(startIndex);\n        return true;\n      }\n      if (!this.#array) {\n        throw new Error('Array not instantiated');\n      }\n      this.#array.setValue(this.#arrayIndex++, nextNumber);\n    }\n  }\n\n  #parseStringsArray(): void {\n    this.#progress.updateStatus('Parsing strings');\n    const closingBracketIndex = this.#json.lastIndexOf(']');\n    if (closingBracketIndex === -1) {\n      throw new Error('Incomplete JSON');\n    }\n    this.#json = this.#json.slice(0, closingBracketIndex + 1);\n\n    if (!this.#snapshot) {\n      throw new Error('No snapshot in parseStringsArray');\n    }\n    this.#snapshot.strings = JSON.parse(this.#json);\n  }\n\n  write(chunk: string): void {\n    this.#buffer.push(chunk);\n    if (!this.#dataCallback) {\n      return;\n    }\n    this.#dataCallback(this.#buffer.shift() as string);\n    this.#dataCallback = null;\n  }\n\n  #fetchChunk(): Promise<string> {\n    // This method shoudln't be entered more than once since parsing happens\n    // sequentially. This means it's fine to stash away a single #dataCallback\n    // instead of an array of them.\n    if (this.#buffer.length > 0) {\n      return Promise.resolve(this.#buffer.shift() as string);\n    }\n\n    const {promise, resolve} = Platform.PromiseUtilities.promiseWithResolvers<string>();\n    this.#dataCallback = resolve;\n    return promise;\n  }\n\n  async #findToken(token: string, startIndex?: number): Promise<number> {\n    while (true) {\n      const pos = this.#json.indexOf(token, startIndex || 0);\n      if (pos !== -1) {\n        return pos;\n      }\n      startIndex = this.#json.length - token.length + 1;\n      this.#json += await this.#fetchChunk();\n    }\n  }\n\n  async #parseArray(name: string, title: string, length?: number):\n      Promise<Platform.TypedArrayUtilities.BigUint32Array> {\n    const nameIndex = await this.#findToken(name);\n    const bracketIndex = await this.#findToken('[', nameIndex);\n    this.#json = this.#json.slice(bracketIndex + 1);\n    this.#array = length === undefined ? Platform.TypedArrayUtilities.createExpandableBigUint32Array() :\n                                         Platform.TypedArrayUtilities.createFixedBigUint32Array(length);\n    this.#arrayIndex = 0;\n    while (this.#parseUintArray()) {\n      if (length) {\n        this.#progress.updateProgress(title, this.#arrayIndex, this.#array.length);\n      } else {\n        this.#progress.updateStatus(title);\n      }\n      this.#json += await this.#fetchChunk();\n    }\n    const result = this.#array;\n    this.#array = null;\n    return result;\n  }\n\n  async #parseInput(): Promise<void> {\n    const snapshotToken = '\"snapshot\"';\n    const snapshotTokenIndex = await this.#findToken(snapshotToken);\n    if (snapshotTokenIndex === -1) {\n      throw new Error('Snapshot token not found');\n    }\n\n    this.#progress.updateStatus('Loading snapshot info');\n    const json = this.#json.slice(snapshotTokenIndex + snapshotToken.length + 1);\n    let jsonTokenizerDone = false;\n    const jsonTokenizer = new TextUtils.TextUtils.BalancedJSONTokenizer(metaJSON => {\n      this.#json = jsonTokenizer.remainder();\n      jsonTokenizerDone = true;\n\n      this.#snapshot = this.#snapshot || {};\n      this.#snapshot.snapshot = (JSON.parse(metaJSON) as HeapSnapshotHeader);\n    });\n    jsonTokenizer.write(json);\n    while (!jsonTokenizerDone) {\n      jsonTokenizer.write(await this.#fetchChunk());\n    }\n\n    this.#snapshot = this.#snapshot || {};\n    const nodes = await this.#parseArray(\n        '\"nodes\"', 'Loading nodes {PH1}%',\n        this.#snapshot.snapshot.meta.node_fields.length * this.#snapshot.snapshot.node_count);\n    this.#snapshot.nodes = nodes;\n\n    const edges = await this.#parseArray(\n        '\"edges\"', 'Loading edges {PH1}%',\n        this.#snapshot.snapshot.meta.edge_fields.length * this.#snapshot.snapshot.edge_count);\n    this.#snapshot.edges = edges;\n\n    if (this.#snapshot.snapshot.trace_function_count) {\n      const traceFunctionInfos = await this.#parseArray(\n          '\"trace_function_infos\"', 'Loading allocation traces {PH1}%',\n          this.#snapshot.snapshot.meta.trace_function_info_fields.length *\n              this.#snapshot.snapshot.trace_function_count);\n      this.#snapshot.trace_function_infos = traceFunctionInfos.asUint32ArrayOrFail();\n\n      const thisTokenEndIndex = await this.#findToken(':');\n      const nextTokenIndex = await this.#findToken('\"', thisTokenEndIndex);\n      const openBracketIndex = this.#json.indexOf('[');\n      const closeBracketIndex = this.#json.lastIndexOf(']', nextTokenIndex);\n      this.#snapshot.trace_tree = JSON.parse(this.#json.substring(openBracketIndex, closeBracketIndex + 1));\n      this.#json = this.#json.slice(closeBracketIndex + 1);\n    }\n\n    if (this.#snapshot.snapshot.meta.sample_fields) {\n      const samples = await this.#parseArray('\"samples\"', 'Loading samples');\n      this.#snapshot.samples = samples.asArrayOrFail();\n    }\n\n    if (this.#snapshot.snapshot.meta['location_fields']) {\n      const locations = await this.#parseArray('\"locations\"', 'Loading locations');\n      this.#snapshot.locations = locations.asArrayOrFail();\n    } else {\n      this.#snapshot.locations = [];\n    }\n\n    this.#progress.updateStatus('Loading strings');\n    const stringsTokenIndex = await this.#findToken('\"strings\"');\n    const bracketIndex = await this.#findToken('[', stringsTokenIndex);\n    this.#json = this.#json.slice(bracketIndex);\n    while (!this.#done) {\n      this.#json += await this.#fetchChunk();\n    }\n    this.#parseStringsArray();\n  }\n}\n"],"names":["HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers","HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame","HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode","IntlMessageFormat.IntlMessageFormat","I18n.I18n.I18n","UIStrings","str_","HeapSnapshotModel.HeapSnapshotModel.Edge","HeapSnapshotModel.HeapSnapshotModel.baseUnreachableDistance","HeapSnapshotModel.HeapSnapshotModel.Node","i18n.i18n.serializeUIString","HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent","Platform.StringUtilities.createPlainTextSearchRegex","HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance","Platform.ArrayUtilities.lowerBound","Platform.ArrayUtilities.DEFAULT_COMPARATOR","HeapSnapshotModel.HeapSnapshotModel.Samples","HeapSnapshotModel.HeapSnapshotModel.Location","HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff","HeapSnapshotModel.HeapSnapshotModel.Diff","HeapSnapshotModel.HeapSnapshotModel.StaticData","Platform.MapUtilities.Multimap","HeapSnapshotModel.HeapSnapshotModel.ItemsRange","Platform.ArrayUtilities.sortRange","HeapSnapshotModel.HeapSnapshotModel.Statistics","i18n.i18n.registerUIStrings","i18n.i18n.getLazilyComputedLocalizedString","i18n.i18n.getLocalizedString","Platform.PromiseUtilities.promiseWithResolvers","Platform.TypedArrayUtilities.createExpandableBigUint32Array","Platform.TypedArrayUtilities.createFixedBigUint32Array","TextUtils.TextUtils.BalancedJSONTokenizer"],"mappings":"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"}